{"meta":{"title":"zakariyyaSv's Blog","subtitle":null,"description":"Just Forcus","author":"zakariyyaSv","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2016-08-30T13:07:24.000Z","updated":"2016-08-30T13:08:58.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"iOS","date":"2016-08-30T12:56:19.000Z","updated":"2016-08-30T12:56:19.000Z","comments":true,"path":"iOS/index.html","permalink":"http://yoursite.com/iOS/index.html","excerpt":"","text":""}],"posts":[{"title":"拆解ARC下的self","slug":"拆解ARC下的self","date":"2016-08-24T13:23:28.000Z","updated":"2016-09-19T14:27:36.000Z","comments":true,"path":"2016/08/24/拆解ARC下的self/","link":"","permalink":"http://yoursite.com/2016/08/24/拆解ARC下的self/","excerpt":"最近在研究AFNetworking源码的过程中碰到了很多处地方用到了weakSelf和strongSelf。依据自己之前的理解，正常情况下使用weakSelf是为了避免发生循环引用，而使用strongSelf是为了避免方法还没有执行完成self已经被释放从而导致崩溃。不过为何在方法执行完成之前无法确保self不被释放却不是很明白，于是乎，自己花了些时间研究了一下。 self的本质self是类的隐藏参数，在类方法中self指向当前调用方法的类，在实例方法中指向当前调用方法的类的init方法族生成的实例。更准确来说，在类方法中self是const Class self，在实例方法中self是Person const* self（以Person类举例）。事实确实如此么？来验证一下。","text":"最近在研究AFNetworking源码的过程中碰到了很多处地方用到了weakSelf和strongSelf。依据自己之前的理解，正常情况下使用weakSelf是为了避免发生循环引用，而使用strongSelf是为了避免方法还没有执行完成self已经被释放从而导致崩溃。不过为何在方法执行完成之前无法确保self不被释放却不是很明白，于是乎，自己花了些时间研究了一下。 self的本质self是类的隐藏参数，在类方法中self指向当前调用方法的类，在实例方法中指向当前调用方法的类的init方法族生成的实例。更准确来说，在类方法中self是const Class self，在实例方法中self是Person const* self（以Person类举例）。事实确实如此么？来验证一下。 12345678910111213141516#import \"Person.h\"@implementation Person- (void)eat&#123;&#125;+ (void)classEat&#123;&#125;- (void)drink:(NSString *)sth&#123; [self eat];&#125;@end 将Person.m用clang命令进行重写，得到的代码如下： 12345678910static void _I_Person_eat(Person * self, SEL _cmd) &#123; id obj = ((Person *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(\"Person\"))&#125;, sel_registerName(\"init\"));&#125;static void _C_Person_classEat(Class self, SEL _cmd) &#123;&#125;static void _I_Person_drink_(Person * self, SEL _cmd, NSString *sth) &#123; ((void (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(\"eat\"));&#125; 从重写后的代码中可以看出结论是正确的，但还是没有找到self在方法执行过程中可能被释放的原因。我又查阅了Clang的官方文档,找到了其中关于self的说明： The self parameter variable of an Objective-C method is never actually retained by the implementation. It is undefined behavior, or at least dangerous, to cause an object to be deallocated during a message send to that object. To make this safe, for Objective-C instance methods self is implicitly const unless the method is in the init family. Further, self is always implicitly const within a class method. 翻译过来就是在OC方法中作为参数的self不会被方法的实现持有，当给self指向的对象发送消息时确实可能会发生错误。为了确保安全，除非是在init及类init的方法中，否则在OC的实例方法和类方法中self始终是指针常量无法被retain。根据我的理解整理如下： 在ARC中，self的修饰符是unsafe_unretained，而不是strong。unsafe_unretained与weak类似，均是对对象的弱引用，区别在于当unsafe_unretained的指针指向的对象被释放后，指针仍会指向被释放对象的内存地址，变成野指针导致crash，而当weak的指针指向的对象被释放后，指针指向的对象会被置为nil。正是由于unsafe_unretained修饰符的作用，因此会导致在方法执行的过程若self被释放则会引起crash。 OC方法不会对self自动retain（除了init方法族以外），self在方法运行过程中的生命周期需要由程序员自己手动实现来保证。通常的做法也就是在方法中添加一个局部变量strongSelf来对self指向的对象进行强引用来保证在方法执行完之前self都不会被释放。 对self采用__unsafe_unretained修饰符，主要是为了性能方面的考虑。通常调用一个方法被runtime改写成objc_msgSend()后，传入的第一个参数都是self，从上面clang重写的代码中也可以看出。若是在方法调用中对self进行retain和release，确实可以保证方法执行过程中self不会被释放，但是，会对性能产生很大影响。并且在大多数方法调用过程中，self是不会被释放的，因此，不对self进行reatain和release操作所带来的性能提升是值得的。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"庖丁解牛KVO（一）————KVO概览和使用","slug":"庖丁解牛KVO（一）————KVO概览和使用","date":"2016-04-13T10:21:33.000Z","updated":"2016-09-19T12:30:46.000Z","comments":true,"path":"2016/04/13/庖丁解牛KVO（一）————KVO概览和使用/","link":"","permalink":"http://yoursite.com/2016/04/13/庖丁解牛KVO（一）————KVO概览和使用/","excerpt":"KVO是对Objective-c观察者模式的实现，也是OC非常强大和有用的特性，同时还是实现cocoa bndings的基础（-bind:toObject:withKeyPath:options:）。因此，理解和掌握KVO可以给我们带来很多便利以及意想不到的效果。 KVO可以让观察者在被观察者的属性被修改时直接接收到通知。在KVO的作用下，一个对象可以观察另一个对象的任何属性，同时，也可以知道某个属性的修改前和修改后的值。对多关系的观察者不仅能知道改变发生的类型，而且还能知道哪些对象被改变了。 在通知机制中，KVO与NSNotification提供的通知机制类似，但是也存在很鲜明的区别。NSNotification是以广播的形式将通知传递给所有注册为观察者的对象，即“一对多”，而KVO则会在属性值发生改变时直接将通知传递给观察者，即“点对点”。","text":"KVO是对Objective-c观察者模式的实现，也是OC非常强大和有用的特性，同时还是实现cocoa bndings的基础（-bind:toObject:withKeyPath:options:）。因此，理解和掌握KVO可以给我们带来很多便利以及意想不到的效果。 KVO可以让观察者在被观察者的属性被修改时直接接收到通知。在KVO的作用下，一个对象可以观察另一个对象的任何属性，同时，也可以知道某个属性的修改前和修改后的值。对多关系的观察者不仅能知道改变发生的类型，而且还能知道哪些对象被改变了。 在通知机制中，KVO与NSNotification提供的通知机制类似，但是也存在很鲜明的区别。NSNotification是以广播的形式将通知传递给所有注册为观察者的对象，即“一对多”，而KVO则会在属性值发生改变时直接将通知传递给观察者，即“点对点”。由于基类NSObject提供了对于KVO的基本实现，因而所有的cocoa对象本质上都能够使用KVO。为了能够接收到KVO的通知，你必须要做以下几件事： 你必须确保被观察类的属性符合KVO规则（KVO Compliance）。KVO规定被观察对象的类必须符合KVC规则（KVC Compliance）同时允许属性的自动观察者通知或者手动实现属性的KVO。 给值会发生改变的对象（即被观察者）添加观察者。你可以通过调用addObserver:forKeyPath:options:context:方法做到。 在观察者对象中，实现方法observeValueForKeyPath:ofObject:change:context:。该方法在被观察对象的属性值发生变化时会被调用。 第二点和第三点很好理解，第一点则需要多说一点。并不是说所有类的属性都满足KVO规则，他需要满足以下几个条件： 类的属性必须满足KVC规则。KVO与KVC支持的数据类型相同，包括OC对象、标量和结构体。 类要发送属性变化的KVO通知。 依赖的键需要被正确的注册。 关于第一点，何为满足KVC规则？对于一个满足KVC规则的指定属性，它必须实现valueForKey:和setValue:forKey:来作用于指定属性。更详细地： 对于対一关系的属性，它的类必须做到： 实现方法名为-&lt;key&gt;，-is&lt;key&gt;的方法，或者创建对象名为或者_的实例对象。 如果属性是可变的，那么它还需要实现-set&lt;key&gt;:方法。 -set&lt;Key&gt;:的方法实现不应该包含验证操作。 若key需要进行验证它的类还需要实现-validate&lt;Key&gt;:error:方法。 对于有索引的对多关系的属性，它的类必须要做到： 实现方法名为-&lt;key&gt;的方法并返回数组。 或者有变量名为或_的实例变量。 或者实现方法-countOf&lt;key&gt;和-objectIn&lt;key&gt;``-&lt;key&gt;AtIndexes:两个方法中的一个。 另外，你可以实现-get&lt;key&gt;:range:来优化性能。 对于无序的对多关系的属性，它的类需要做到： 实现方法名为-&lt;key&gt;的方法并并返回一个集合。 或者创建变量名为或_的实例变量。 或者实现方法-countOf&lt;key&gt;、-enumeratorOf&lt;key&gt;和-memberOf&lt;key&gt;:。若该属性还是可变的，它的类还需做到： 实现-add&lt;key&gt;Object:和-add&lt;key&gt;:中的一个或两个。 实现-remove&lt;key&gt;Object:和-remove&lt;key&gt;:中的一个或两个。 另外，你可以实现-intersect&lt;key&gt;:和-set&lt;key&gt;:来优化性能。 关于第二点，如何确保通知被发送？对于所有满足KVC规则的类的属性已经自动支持KVO。因此，只要你遵守标准Cocoa编码和命名规范，你可以使用自动变化通知（Automatic Change Notification）————你不需要编写额外的代码。以下代码示例会触发KVO变化通知被发送：12345678910111213// Call the accessor method.[account setName:@&quot;Savings&quot;]; // Use setValue:forKey:.[account setValue:@&quot;Savings&quot; forKey:@&quot;name&quot;]; // Use a key path, where &apos;account&apos; is a kvc-compliant property of &apos;document&apos;.[document setValue:@&quot;Savings&quot; forKeyPath:@&quot;account.name&quot;]; // Use mutableArrayValueForKey: to retrieve a relationship proxy object.Transaction *newTransaction = &lt;#Create a new transaction for the account#&gt;;NSMutableArray *transactions = [account mutableArrayValueForKey:@&quot;transactions&quot;];[transactions addObject:newTransaction]; 在某些情况下，你想控制通知的进程，比如想减少不必要的原因而触发通知的次数，或者想把多个变化整合进一个通知当中。这时候自动变化通知就无法满足需求，而手动变化通知（Manual Change Notification）则派上用场了。在这种情况下，你需要重写NSObject的automaticallyNotifiesObserversForKey:方法。若你想将某个属性从自动变化通知中移除，则在automaticallyNotifiesObserversForKey:方法中返回NO。1234567891011+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey &#123; BOOL automatic = NO; if ([theKey isEqualToString:@&quot;balance&quot;]) &#123; automatic = NO; &#125; else &#123; automatic = [super automaticallyNotifiesObserversForKey:theKey]; &#125; return automatic;&#125; 为了实现手动变化通知，你需要在改变变量值�前触发willChangeValueForKey:方法并在改变变量值后触发didChangeValueForKey:方法。12345- (void)setBalance:(double)theBalance &#123; [self willChangeValueForKey:@&quot;balance&quot;]; _balance = theBalance; [self didChangeValueForKey:@&quot;balance&quot;];&#125; 你可以通过检验值是否发生改变来减少不必要的通知发送。1234567- (void)setBalance:(double)theBalance &#123; if (theBalance != _balance) &#123; [self willChangeValueForKey:@&quot;balance&quot;]; _balance = theBalance; [self didChangeValueForKey:@&quot;balance&quot;]; &#125;&#125; 若一个操作引起多个属性值发生变化，你必须像下面这样嵌套变化的通知：12345678- (void)setBalance:(double)theBalance &#123; [self willChangeValueForKey:@&quot;balance&quot;]; [self willChangeValueForKey:@&quot;itemChanged&quot;]; _balance = theBalance; _itemChanged = _itemChanged+1; [self didChangeValueForKey:@&quot;itemChanged&quot;]; [self didChangeValueForKey:@&quot;balance&quot;];&#125; 在有序的对多关系的属性中，你必须不仅指明改变的属性，而且还需指明改变的类型和涉及到的对象的索引值。改变的类型是NSKeyValueChange枚举，包含NSKeyValueChangeInsertion, NSKeyValueChangeRemoval, NSKeyValueChangeReplacement。受影响的对象的索引值传入的是NSIndexSet对象。123456789- (void)removeTransactionsAtIndexes:(NSIndexSet *)indexes &#123; [self willChange:NSKeyValueChangeRemoval valuesAtIndexes:indexes forKey:@&quot;transactions&quot;]; // Remove the transaction objects at the specified indexes. [self didChange:NSKeyValueChangeRemoval valuesAtIndexes:indexes forKey:@&quot;transactions&quot;];&#125; 关于第三点，在很多情况下某个属性依赖于另一个对象的一个或多个属性。如果一个属性值发生改变，那么受影响的属性其值也会发生改变。那么如何确保存在依赖关系的属性的KVO通知能正确发送？ 在対一关系中，为了触发自动通知你需要重写keyPathsForValuesAffectingValueForKey:方法。比如，一个人的名字包含姓和名。他的名字的全称可以用以下方法来写：123- (NSString *)fullName &#123; return [NSString stringWithFormat:@&quot;%@ %@&quot;,firstName, lastName];&#125; 当firstName或者lastName属性值发生改变时，观察fullName的对象必须接收到通知。其中一个解决方法是重写keyPathsForValuesAffectingValueForKey:方法来指明fullName属性依赖于lastName和firstName属性。12345678910+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key &#123; NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key]; if ([key isEqualToString:@&quot;fullName&quot;]) &#123; NSArray *affectingKeys = @[@&quot;lastName&quot;, @&quot;firstName&quot;]; keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys]; &#125; return keyPaths;&#125; 如上面代码示例中，你的重写方法实现中必须要触发super方法调用，并且返回的集合中要包含父类的keys。你还可以通过实现命名规则遵循keyPathsForValuesAffecting&lt;Key&gt;（Key为属性名并且首字母大写）的类方法来得到同样的结果。使用该方案对上面代码进行改写如下：123+ (NSSet *)keyPathsForValuesAffectingFullName &#123; return [NSSet setWithObjects:@&quot;lastName&quot;, @&quot;firstName&quot;, nil];&#125; 当你使用分类给现有的类添加属性时，不能重写keyPathsForValuesAffectingValueForKey:方法，因为在分类中不支持重写该方法。在这种情况下，只能通过实现keyPathsForValuesAffecting&lt;Key&gt;类方法来达到效果。 在对多关系中，keyPathsForValuesAffectingValueForKey:方法不支持。比如，你有一个Deprtment对象与employee对象的对多关系，并且employee有salary属性。在Department对象中有一个totalSalary属性依赖于所有的employee的salary的关系。这里有两种解决方案：1.你可以使用KVO注册父类（Department）为所有子类（employee）的salary属性的观察者。你必须在添加和移除子类对象的过程中添加和移除观察者。以下为示例代码：12345678910111213141516171819202122232425- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123; if (context == totalSalaryContext) &#123; [self updateTotalSalary]; &#125; else // deal with other observations and/or invoke super...&#125; - (void)updateTotalSalary &#123; [self setTotalSalary:[self valueForKeyPath:@&quot;employees.@sum.salary&quot;]];&#125; - (void)setTotalSalary:(NSNumber *)newTotalSalary &#123; if (_totalSalary != newTotalSalary) &#123; [self willChangeValueForKey:@&quot;totalSalary&quot;]; _totalSalary = newTotalSalary; [self didChangeValueForKey:@&quot;totalSalary&quot;]; &#125;&#125; - (NSNumber *)totalSalary &#123; return _totalSalary;&#125; 2.如果你使用Core Data，你可以注册父类为它管理对象上下文的观察者。当子类相关属性值发生改变其父类就会得到相应的通知，类似于KVO。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"Mac workflow小记","slug":"Mac workflow小记","date":"2016-03-12T12:11:39.000Z","updated":"2016-08-31T12:36:47.000Z","comments":true,"path":"2016/03/12/Mac workflow小记/","link":"","permalink":"http://yoursite.com/2016/03/12/Mac workflow小记/","excerpt":"在Mac平台下做开发也有一段时间了，虽然说相对于windows平台而言，Mac下的软件资源并不如windows下的那么丰富，但是在适应以及找到合适的软件后，我觉得Mac对我而言更适合做开发。对于开发人员来说，效率至上是毋庸置疑的，因此，拥有一套提升效率的软件和工具对于开发人员来说是至关重要的。这篇博客就记录下我自己开发的workflow，也希望通过这篇博客能与他人分享。 Homebrew Homebrew之于Mac的关系就跟apt之于Linux的关系是一样的，它实际上是Mac下的套件管理器。比如你想安装MySQL、git等等工具软件，都可以使用homebrew来下载和管理。homebrew的安装也非常方便，你可以去到它的官网，根据提示进行安装。安装成功后就使用homebrew的命令去下载和管理你需要的工具软件了。","text":"在Mac平台下做开发也有一段时间了，虽然说相对于windows平台而言，Mac下的软件资源并不如windows下的那么丰富，但是在适应以及找到合适的软件后，我觉得Mac对我而言更适合做开发。对于开发人员来说，效率至上是毋庸置疑的，因此，拥有一套提升效率的软件和工具对于开发人员来说是至关重要的。这篇博客就记录下我自己开发的workflow，也希望通过这篇博客能与他人分享。 Homebrew Homebrew之于Mac的关系就跟apt之于Linux的关系是一样的，它实际上是Mac下的套件管理器。比如你想安装MySQL、git等等工具软件，都可以使用homebrew来下载和管理。homebrew的安装也非常方便，你可以去到它的官网，根据提示进行安装。安装成功后就使用homebrew的命令去下载和管理你需要的工具软件了。注：homebrew的安装程序需要用到Xcode的command line tools。 1234567brew install mysql // 安装MySQLbrew uninstall mysql // 卸载MySQLbrew search mysql // 搜索MySQLbrew upgrade mysql // 更新MySQLbrew list // 显示已经安装的软件列表brew update // 更新homebrewbrew deps mysql // 显示MySQL的包依赖 iTerm2 iTerm2是mac下的替代Terminal的终端工具，可以说iTerm2是Mac下最好的终端工具。它有一些特色功能如下： 标签变色iTerm2 的标签的颜色会变化，以指示该 tab 当前的状态。当该标签有新输出的时候，标签会变成洋红色；新的输出长时间没有查看，标签会变成红色。可在设置中关掉该功能。 智能选中在 iTerm2 中，双击选中，三击选中整行，四击智能选中（智能规则可配置），可以识别网址，引号引起的字符串，邮箱地址等。（很多时候双击的选中就已经很智能了）在 iTerm2 中，选中即复制。即任何选中状态的字符串都被放到了系统剪切板中。 巧用 Command 键按住⌘键:可以拖拽选中的字符串；点击 url：调用默认浏览器访问该网址；点击文件：调用默认程序打开文件；如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行；点击文件夹：在 finder 中打开该文件夹；同时按住option键，可以以矩形选中，类似于vim中的ctrl v操作。 iTerm2的可定制化也是一大特色，详细的定制化步骤可以参见我的另一篇博客。 Alfred3 我对Alfred3的评价是Mac下最逆天的工具。如果你是个键盘党，Alfred绝对可以让你基本摆脱鼠标。丰富的workflow可以让你的操作变得得心应手而且高效。你可以去alfredworkflow上下载安装适合你的workflow。当然，你要是想自己制作workflow也很容易，简单易上手，这也是Alfred workflow资源丰富的原因所在。如果兜里不差钱还是建议去买个终身会员，绝对值得。如果囊中羞涩，这里提供一个破解版本供大家尝鲜。（下载链接） Dash Dash是Mac下的API文档查阅器，其储存了超过150种API离线文档。这可以说是程序员必备利器，不管是从操作体验以及资源的丰富程度都是Mac平台下最好用的。同时，配合Alfred使用，效率会更高。Dash提供免费版也带有付费插件，如果不差钱，支持一下也是无可厚非的。 CheatSheet CheatSheet是一款Mac上非常实用的快捷键快速提醒工具，只需要按住Command键，就会弹出当前应用所有的快捷键列表。所以，即使你记不住一些快捷键也没有关系，有CheatSheet就够了。 Sequel Pro Sequel Pro（原CocoaMySQL）是众多Mac程序员使用的MySQL管理软件，提供了比phpmyadmin更强大的管理能力，帮助用户轻松编辑数据库，表（字段和索引）和列，执行个性化查找以及导出/入数据，快速查询数据。 Sequel Pro它最大的优点是简单、易用。因为这款工具是苹果公司为了吸引Web开发者进入Mac平台而投资的项目。所以它处处体现了苹果公司简洁的设计哲学。说它是全世界最好用的MySQL数据库管理工具是一点也不夸张。 功能特点： 支持多达30种编码方式 快速导出/导入、备份/还原数据库的SQL/CSV文件 最高版本支持MySQL 5.6 内置强大的数据库查询编辑器，有自定义查询中的自动语句高亮功能，可自定义字体，自定义查询占位符. 允许你编辑数据库，表格（字段和索引）和列，执行个性化查找和导入导出数据 自动补全关键词，表名，域名 自动段落化查询命令 IP直连数据库 表触发机制 服务器运行监控Query Favourites for SQL reuse 包括检索功能在内的全表管理设计 快速在Mac上架设本地MySQL数据库 在MAMP/XAMP架构上连接数据库 SSH连接模式 Sublime Text 3 Sublime Text可以说是一款优雅高效地编辑器，越来越受到开发人员的欢迎。这款编辑器区别于其他编辑器的特性主要有以下几点： 随时保留文件的修改 多重选择，同时修改 智能选择 智能感知，一键注释 Goto Anything，智能搜索 自动完成，无处不在 HTML标签输入 标签输入，再简化 简单全面的插件体系 Lantern Lantern是一款免费开源的科学上网的软件，安装和使用极其简单。Lantern让用户能流畅地访问被封锁的互联网站点。Lantern自动检测一个网站是否被封锁。对那些被封锁的网站，Lantern通过自有的服务器或者未封锁地区的用户运行的Lantern来提供访问。如果网站没有被封锁，Lantern选择靠边站。这样浏览器就会直接访问网站，而速度不受影响。 iStat Menus iStat Menus 5 是一款由软件开发商 Bjango 制作的 System Monitor（工具，也是笔者电脑里的必装应用之一，它能让用户最快速、最直观地了解到几乎各硬件所有的运行状态，其中包括：CPU 中央处理器、GPU 图形处理器、Memory 虚拟内存、Network 网络、Battery 电池、Disks 硬盘等。 Cmd Markdown编辑器 Cmd Markdown是一款markdown编辑器，相比于同类markdown编辑器，Cmd Markdown编辑器的优势在于对中文支持比较好，实时的云端文稿，实时同步预览等等。 目前，也就只有这些了，后续如果发现好用的软件会继续更新的。","categories":[{"name":"Mac相关","slug":"Mac相关","permalink":"http://yoursite.com/categories/Mac相关/"}],"tags":[],"keywords":[{"name":"Mac相关","slug":"Mac相关","permalink":"http://yoursite.com/categories/Mac相关/"}]},{"title":"深入理解NSMapTable、NSHashTable、NSPointerArray","slug":"深入理解NSMapTable、NSHashTable、NSPointerArray","date":"2016-03-10T02:19:45.000Z","updated":"2016-09-08T13:47:22.000Z","comments":true,"path":"2016/03/10/深入理解NSMapTable、NSHashTable、NSPointerArray/","link":"","permalink":"http://yoursite.com/2016/03/10/深入理解NSMapTable、NSHashTable、NSPointerArray/","excerpt":"最近在学习YYCache中的YYDiskCache时，注意到了这段代码： 12345678910111213141516171819202122232425262728/// weak reference for all instancesstatic NSMapTable *_globalInstances;static dispatch_semaphore_t _globalInstancesLock;static void _YYDiskCacheInitGlobal() &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _globalInstancesLock = dispatch_semaphore_create(1); _globalInstances = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0]; &#125;);&#125;static YYDiskCache *_YYDiskCacheGetGlobal(NSString *path) &#123; if (path.length == 0) return nil; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); id cache = [_globalInstances objectForKey:path]; dispatch_semaphore_signal(_globalInstancesLock); return cache;&#125;static void _YYDiskCacheSetGlobal(YYDiskCache *cache) &#123; if (cache.path.length == 0) return; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); [_globalInstances setObject:cache forKey:cache.path]; dispatch_semaphore_signal(_globalInstancesLock);&#125;","text":"最近在学习YYCache中的YYDiskCache时，注意到了这段代码： 12345678910111213141516171819202122232425262728/// weak reference for all instancesstatic NSMapTable *_globalInstances;static dispatch_semaphore_t _globalInstancesLock;static void _YYDiskCacheInitGlobal() &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _globalInstancesLock = dispatch_semaphore_create(1); _globalInstances = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0]; &#125;);&#125;static YYDiskCache *_YYDiskCacheGetGlobal(NSString *path) &#123; if (path.length == 0) return nil; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); id cache = [_globalInstances objectForKey:path]; dispatch_semaphore_signal(_globalInstancesLock); return cache;&#125;static void _YYDiskCacheSetGlobal(YYDiskCache *cache) &#123; if (cache.path.length == 0) return; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); [_globalInstances setObject:cache forKey:cache.path]; dispatch_semaphore_signal(_globalInstancesLock);&#125; YYDiskCache采用NSMapTable作为全局变量而并没有采用NSDictionary来存储cache变量，这样做的好处是避免_globalInstances与cache发生循环引用，造成内存无法释放。回顾之前自己的编码经历，基本没考虑过NSDictionary与其元素可能发生的循环引用问题，不得不说自己在这方面还是有欠缺。因而写下这篇blog总结这部分的内容。 我在总结的过程中发现了NSMapTable-NSDictionary、NSHashTable-NSSet、NSPointerArray-NSArray三组存在相似的关系，于是我就想干脆将这几个类总结在一起，便于理解。 NSMapTable - NSDictionary以下是苹果文档关于NSMapTable的描述： The NSMapTable class is a mutable collection modeled after NSDictionary, with the following differences: The major option is to have keys and/or values held “weakly” in a manner that entries are removed when one of the objects is reclaimed. Its keys or values may be copied on input or may use pointer identity for equality and hashing. It can contain arbitrary pointers (its contents are not constrained to being objects). 总结一下，NSMapTable仿效的是NSDictionary，但它是可变的集合。它与NSDictionary有几点区别： 1.NSMapTable与NSDictionary最重要的区别在于前者可以将keys和values以弱引用的方式关联，当其中任一对象被回收了，其所有的内容都会被移除。我们可以通过mapTableWithKeyOptions:valueOptions:分别控制键和值的对象获取/保留行为。NSDictionary则会对keys和values执行retain操作，只有等到NSDictionary被release才会release它所持有的keys和values。 NSMapTable可以包含任意的指针并且指针的内容不限定必须是对象，然后用指针去做相等或者hasing检查，而NSDictionary的key必须是遵循NSCopying协议的对象。不仅如此，如果NSDictionary要使用KVC那么key必须是字符串。 当NSMapTable指定为NSMapTableCopyIn，它会通过NSCopying协议将添加进来的数据复制一份副本，NSDictionary则需要调用copy方法来复制数据。 NSHashTable - NSSet以下是苹果文档关于NSHashTable的描述： NSHashTable is modeled after NSSet but provides different options, in particular to support weak relationships. It can hold weak references to its members. Its members may be copied on input or may use pointer identity for equality and hashing. It can contain arbitrary pointers (its members are not constrained to being objects). Because of its options, NSHashTable is not a set because it can behave differently (for example, if pointer equality is specified two isEqual: strings will both be entered). 总结一下，NSHashTable效仿的是NSSet但提供更多不同的选项，尤其是支持weak关联。它支持对所有成员的弱引用，而NSSet对所有成员均是强引用。其他的不同点与前面NSMapTable与NSDictionary类似，可以参考对比，就不再码废话了。 NSPointerArray - NSArray以下是苹果文档关于NSPointerArray的描述： The NSPointerArray class represents a mutable collection modeled after NSArray, but can also hold nil values. nil values may be inserted or removed and contribute to the object’s count. An NSPointerArray object can also increase and decrease its count directly. A pointer array can be initialized to maintain strong or weak references to objects, or according to any of the memory or personality options defined by NSPointerFunctionsOptions. The NSCopying and NSCoding protocols are applicable only when a pointer array is initialized to maintain strong or weak references to objects. When enumerating a pointer array with NSFastEnumeration using for…in, the loop will yield any nil values present in the array. See Fast Enumeration Makes It Easy to Enumerate a Collection in Programming with Objective-C for more information. 总结一下，NSPointerArray效仿的是NSArray，但可以存储值为nil的元素。nil可以被插入和移除并且计入对象的数目中。而NSArray不可以存储nil，通常它会将nil看做数组的终止符，并且不会计入到对象的数目当中。NSPointerArray可以直接增加或减少元素的数量，与NSMutableArray类似。NSPointerArray最重要的特性与前面两组相同，均是可以对存储的对象采用弱引用。只有当NSPointerArray存储的是对象时NSCopying、NSCoding协议才会适用。还有一点要注意的，在快速遍历的for…in方法中，如果NSPointerArray存在nil则循环遍历会终止。 结语依据这三组类的不同也就归纳出它们各自的应用场景。若你的使用场景中可能会产生如实例代码中的循环引用问题，那就使用前者，若你的使用场景中存储的对象不遵循NSCopying协议或者就不是对象，而是指针之类，那就使用前者。其他大多数情况下还是使用后者。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"YYCache源码学习","slug":"YYCache源码学习","date":"2016-03-06T06:17:28.000Z","updated":"2016-09-07T13:10:24.000Z","comments":true,"path":"2016/03/06/YYCache源码学习/","link":"","permalink":"http://yoursite.com/2016/03/06/YYCache源码学习/","excerpt":"这篇文章并不是对YYCache的设计思路的范范分析，而是对YYCache代码实现的详细分析。一方面YYCache的设计思路作者已经写得比较清楚了，我就没必要再多此一举了，有兴趣的可以到大神的博客去看YYCache 设计思路。从代码层面进行分析，一方面是因为很多思路上的东西很虚理解起来大都很容易，但是要能用代码实现却往往不那么轻松，另一方面是因为代码分析可以学习优秀代码的编码风格以及加深对iOS技术上的理解，这样做给自己带来的帮助或许会更多。 代码结构YYCache文件数并不多，主要包含四个文件： YYCache YYDiskCache YYMemoryCache YYKVStorage","text":"这篇文章并不是对YYCache的设计思路的范范分析，而是对YYCache代码实现的详细分析。一方面YYCache的设计思路作者已经写得比较清楚了，我就没必要再多此一举了，有兴趣的可以到大神的博客去看YYCache 设计思路。从代码层面进行分析，一方面是因为很多思路上的东西很虚理解起来大都很容易，但是要能用代码实现却往往不那么轻松，另一方面是因为代码分析可以学习优秀代码的编码风格以及加深对iOS技术上的理解，这样做给自己带来的帮助或许会更多。 代码结构YYCache文件数并不多，主要包含四个文件： YYCache YYDiskCache YYMemoryCache YYKVStorage 他们之间的关系可以用一张图来描述： YYCache是整个缓存框架的核心类，它是由YYDiskCache和YYMemeoryCache组成，而YYDiskCache需要借助YYKVStorage来实现对元素的读写。以下就依次对每个类进行详细的剖析，我觉得由下向上的去看代码理解起来会更方便，于是剖析的顺序依次是YYKVStorage、YYDiskCache、YYMemeoryCache、YYCache。 YYKVStorageYYKVStorage文件中包含两个类YYKVStorageItem和YYKVStorage，前者的作用是为后者提供存储键值对和元数据服务的。前者将每一个储存的数据包装成一个元素，是静态的，后者则是对前者的元素进行读写操作，是动态的。做个比喻，YYKVStorageItem就好比是仓库里的货物，而YYKVStorage则是仓库管理员。不过，该类并非是线程安全的，所以，需要确保该类同一时间只能由一个YYKVStorage对象去访问某个YYKVStorageItem元素。YYKVStorageItem的结构很简单：123456789@interface YYKVStorageItem : NSObject@property (nonatomic, strong) NSString *key; ///&lt; key@property (nonatomic, strong) NSData *value; ///&lt; value@property (nullable, nonatomic, strong) NSString *filename; ///&lt; filename (nil if inline)@property (nonatomic) int size; ///&lt; value&apos;s size in bytes@property (nonatomic) int modTime; ///&lt; modification unix timestamp@property (nonatomic) int accessTime; ///&lt; last access unix timestamp@property (nullable, nonatomic, strong) NSData *extendedData; ///&lt; extended data (nil if no extended data)@end key：唯一标示元素的标识符value：存储的二进制数据filename：存储数据文件的文件名size：限定存储数据的大小modTime：最后一次修改数据的时间戳accessTime：最后一次读取数据的时间戳extendedData：附加的数据 YYKVStorage类的结构如下：123456@interface YYKVStorage : NSObject#pragma mark - Attribute@property (nonatomic, readonly) NSString *path; ///&lt; The path of this storage.@property (nonatomic, readonly) YYKVStorageType type; ///&lt; The type of this storage.@property (nonatomic) BOOL errorLogsEnabled; ///&lt; Set `YES` to enable error logs for debug.@end path：存储的路径type：存储类型errorLogsEnabled：debug下是否打印错误信息注：由于写入速度方面sqlite比文件速度快，但是读取速度方面的性能则取决于数据的大小。在作者的测试当中，当数据大于20KB时，读取速度上文件要快于sqlite。为了从性能方面考虑，加入了YYKVStorageType枚举类型。1234567891011typedef NS_ENUM(NSUInteger, YYKVStorageType) &#123; /// The `value` is stored as a file in file system. YYKVStorageTypeFile = 0, /// The `value` is stored in sqlite with blob type. YYKVStorageTypeSQLite = 1, /// The `value` is stored in file system or sqlite based on your choice. YYKVStorageTypeMixed = 2,&#125;; 如果是要存储大量的小数据，用YYKVStorageTypeSQLite性能会更好，如果是要存储大文件（比如图片缓存），使用YYKVStorageTypeFile来获取更好的性能，当然也可以使用YYKVStorageTypeMixed来自己决定每一个item的存储方式。 YYKVStorage实现文件依据它的思路分为两部分：sqlite和文件，它们的存储结构如下：12345678910111213141516171819202122232425/* File: /path/ /manifest.sqlite /manifest.sqlite-shm /manifest.sqlite-wal /data/ /e10adc3949ba59abbe56e057f20f883e /e10adc3949ba59abbe56e057f20f883e /trash/ /unused_file_or_folder SQL: create table if not exists manifest ( key text, filename text, size integer, inline_data blob, modification_time integer, last_access_time integer, extended_data blob, primary key(key) ); create index if not exists last_access_time_idx on manifest(last_access_time); */ File和SQL共用一张manifest表，如果是用SQL方式存储数据，则manifest表中的filename字段为空。这样设计的好处是，查询和修改item的信息只要查询一张表，效率上会高一点。 注：manifest.sqlite-shm和manifest.sqlite-wal是自sqlite 3.7后加入的，-wal文件的意思是write-ahead log，当一个数据库采用WAL模式，所有连接数据的操作都必须使用WAL，然后在数据库文件夹下生成后缀为-wal的文件来保存操作日志，-shm则说的是共享内存的问题，有兴趣可以看看下面这段。 2.2 Write-Ahead Log (WAL) Files A write-ahead log or WAL file is used in place of a rollback journal when SQLite is operating in WAL mode. As with the rollback journal, the purpose of the WAL file is to implement atomic commit and rollback. The WAL file is always located in the same directory as the database file and has the same name as the database file except with the 4 characters “-wal” appended. The WAL file is created when the first connection to the database is opened and is normally removed when the last connection to the database closes. However, if the last connection does not shutdown cleanly, the WAL file will remain in the filesystem and will be automatically cleaned up the next time the database is opened. 2.3 Shared-Memory Files When operating in WAL mode, all SQLite database connections associated with the same database file need to share some memory that is used as an index for the WAL file. In most implementations, this shared memory is implemented by calling mmap() on a file created for this sole purpose: the shared-memory file. The shared-memory file, if it exists, is located in the same directory as the database file and has the same name as the database file except with the 4 characters “-shm” appended. Shared memory files only exist while running in WAL mode. The shared-memory file contains no persistent content. The only purpose of the shared-memory file is to provide a block of shared memory for use by multiple processes all accessing the same database in WAL mode. If the VFS is able to provide an alternative method for accessing shared memory, then that alternative method might be used rather than the shared-memory file. For example, if PRAGMA locking_mode is set to EXCLUSIVE (meaning that only one process is able to access the database file) then the shared memory will be allocated from heap rather than out of the shared-memory file, and the shared-memory file will never be created. The shared-memory file has the same lifetime as its associated WAL file. The shared-memory file is created when the WAL file is created and is deleted when the WAL file is deleted. During WAL file recovery, the shared memory file is recreated from scratch based on the contents of the WAL file being recovered. sqlite3部分涉及到sqlite3预编译，它的预编译过程分为以下几步： 1.通过sqlite3_prepare_v2()创建sqlite3_stmt对象2.通过sqlite3bind*()绑定预编译字段的值3.通过sqlite2_step()执行SQL语句4.通过sqlite3_reset()重置预编译语句，重复步骤2多次5.通过sqlite3_finalize()销毁资源 sqlite3bind*有多种形式，分别对应不同的类型：123456789int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*)); int sqlite3_bind_double(sqlite3_stmt*, int, double);int sqlite3_bind_int(sqlite3_stmt*, int, int);int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);int sqlite3_bind_null(sqlite3_stmt*, int);int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*));int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n); YYDiskCacheYYDiskCache是线程安全的底层依赖于SQLite和File系统（类似于NSURLCache的磁盘缓存）来存储键值对的缓存YYDiskCache有以下的特性： 使用LRU算法来移除对象 能够被开销、数量和寿命来控制 当没有多余的磁盘空间时它能够自动回收对象 能够自动决定为每个对象决定存储类型（sqlite还是文件）以达到更好的性能 YYDiskCache结构如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@interface YYDiskCache : NSObject#pragma mark - Attribute/** The name of the cache. Default is nil. */@property (nullable, copy) NSString *name;/** The path of the cache (read-only). */@property (readonly) NSString *path;/** * 如果对象的数据大小超过这个值，那对象就会被当做文件存储起来，否则对象会以sqlite形式存储起来。 0意味着所有的对象会被以单独的文件存储起来，NSIntegerMax意味着所有的对象都会以sqlite形式存储。 */@property (readonly) NSUInteger inlineThreshold;/** * 如果这个block不为空，那么这个block会被用来取代NSKeyedArchiver序列化对象。 * 你可以使用这个block来支持那些没有实现&apos;NSCoding&apos;协议的对象 */@property (nullable, copy) NSData *(^customArchiveBlock)(id object);/** * 反序列化那些没有遵从&apos;NSCoding&apos;协议的对象 */@property (nullable, copy) id (^customUnarchiveBlock)(NSData *data);/** * 当一个对象需要以文件的形式存储起来时，这个block会被触发来以指定的key生成文件名。 如果block为空，缓存就使用md5加密的key来作为文件名 */@property (nullable, copy) NSString *(^customFileNameBlock)(NSString *key);#pragma mark - Limit/** * 缓存所拥有的对象的最大限制 默认值为NSIntegMax，这不是一个严格的限制——如果缓存超过了这个限制，一些对象会在后台队列中被回收 */@property NSUInteger countLimit;/** * 在缓存开始回收对象前它所能持有的所有代价 如果缓存超过这个限制，一些对象会在后台队列中被回收。 */@property NSUInteger costLimit;/** * 缓存中对象的生命周期 如果对象超过这个限制，它会在后台队列中被回收 */@property NSTimeInterval ageLimit;/** * 缓存保有的最小的空余磁盘空间大小 如果空余磁盘空间大小小于这个值，缓存会移除部分对象来释放磁盘空间。 */@property NSUInteger freeDiskSpaceLimit;/** * 缓存有一个内部的timer来检查缓存是否达到它的限制，如果达到限制，便开始回收对象。 */@property NSTimeInterval autoTrimInterval;/** Set `YES` to enable error logs for debug. */@property BOOL errorLogsEnabled; YYDiskCache实现部分采用dispatch_semaphore来控制同步的，而并没有采用性能非常好的OSSpinLock自旋锁，研究了一下原因。 OSSpinLock：得益于不进内核不挂起的方式，OSSpinLock有着优异的性能表现，然而在高并发执行(冲突概率大，竞争激烈)的时候，又或者代码片段比较耗时(比如涉及内核执行文件io、socket、thread等)，就容易引发CPU占有率暴涨的风险，因此更适用于一些简短低耗时的代码片段dispatch_semaphore：GCD用于控制多线程并发的信号量，允许通过wait/signal的信号事件控制并发执行的最大线程数，当最大线程数降级为1的时候则可当作同步锁使用，注意该信号量并不支持递归；性能虽不如OSSpinLock但性能表现也是出乎意料之外的好，也没有OSSpinLock的CPU占有率暴涨的问题，然而原本是用于GCD的多线程并发控制，也是信号量机制。 对于耗时较大又易冲突的读操作，可以使用dispatch_semaphore，对于性能要求苛刻，可以考虑使用OSSpinLock，但需要确保加锁片段的耗时足够小。由于YYDiskCache锁占用时间会比较长，使用OSSpinLock会造成CPU内存暴涨，相比之下，使用dispatch_semaphore性能上则会好很多。 YYMemoryCacheYYMemoryCache是一个高效的存储键值对的内存缓存。与NSDictionary相比，keys只被持有而并不进行拷贝, 其API和性能与NSCache接近，所有的方法都是线程安全的。它的特性如下： YYMemoryCache与NSCache在以下几个方面不同： 它使用LRU算法移除对象；NSCache的回收方法的策略是不确定的。 它可以被开销，数量和生命周期来控制；NSCache的限制是不确定的。 当收到内存警告和进入后台时，它可以自动回收对象。 YYMemoryCache使用pthread_mutex来控制同步。读写锁的在锁操作耗时上明显不占优势，读写锁的主要性能优势在于多线程高并发量的场景，这时候锁竞争可能会非常激烈，使用一般的锁这时候并发性能都会明显下降，读写锁对于所有读操作能够把同步放开，进而保持并发性能不受影响。由于内存缓存属于多线程高并发的使用场景，因此使用pthread_mutex会更稳定。 pthread_mutex：POSIX标准的unix多线程库(pthread)中使用的互斥量，支持递归，需要特别说明的是信号机制pthread_cond_wait()同步方式也是依赖于该互斥量，pthread_cond_wait()本身并不具备同步能力； YYMemoryCache的实现主要基于双链表，将链表的节点按照时间先后顺序逆序链接，若有节点被访问，则将该节点挪到表头，若插入新节点而缓存已满，则从链表表尾开始删除节点腾出存储空间。12345678910@interface _YYLinkedMapNode : NSObject &#123; @package __unsafe_unretained _YYLinkedMapNode *_prev; // retained by dic __unsafe_unretained _YYLinkedMapNode *_next; // retained by dic id _key; id _value; NSUInteger _cost; NSTimeInterval _time;&#125;@end YYMemoryCache创建一个YYMemoryCacheGetReleaseQueue来releaseCFMutableDictionaryRef对象，避免阻塞主线程。123static inline dispatch_queue_t YYMemoryCacheGetReleaseQueue() &#123; return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);&#125; YYMemoryCache的实现部分有段代码引起了我的注意：12345678910111213141516171819- (void)removeObjectForKey:(id)key &#123; if (!key) return; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); if (node) &#123; [_lru removeNode:node]; if (_lru-&gt;_releaseAsynchronously) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [node class]; //hold and release in queue &#125;); &#125; else if (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [node class]; //hold and release in queue &#125;); &#125; &#125; pthread_mutex_unlock(&amp;_lock);&#125; 这段代码实现的很巧妙，removeObjectForKey:方法执行完之后，node指向的对象的引用计数为0需要被释放，但是由于在dispatch_async方法中的block中调用了[node class];，使得blcok持有node，其指向的对象也就不会释放，而此时只有dispatch_async的block持有node，也就自然node释放的过程发生在dispatch_async指定的线程当中。 YYCacheYYCache是线程安全的键值对缓存。它使用YYMemoryCache将对象存储在速度快但空间小的内存缓存中，使用YYDiskCache将对象持久化存储在速度慢但空间大的磁盘缓存中。其类结构也很简单：12345678@interface YYCache : NSObject/** The name of the cache, readonly. */@property (copy, readonly) NSString *name;/** The underlying memory cache. see `YYMemoryCache` for more information.*/@property (strong, readonly) YYMemoryCache *memoryCache;/** The underlying disk cache. see `YYDiskCache` for more information.*/@property (strong, readonly) YYDiskCache *diskCache;@end YYCache没有太复杂的实现细节，主要就是调用YYMemoryCache和YYDiskCache相关方法存储、查找、修改、删除对象。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"runtime对containsString方法的小改进","slug":"runtime对containsString方法的小改进","date":"2016-02-20T15:23:28.000Z","updated":"2016-09-06T15:27:00.000Z","comments":true,"path":"2016/02/20/runtime对containsString方法的小改进/","link":"","permalink":"http://yoursite.com/2016/02/20/runtime对containsString方法的小改进/","excerpt":"最近做项目过程中版本适配到iOS 7上出现了一点问题，定位分析了一下发现原来是NSstring的containsString:方法在从中作梗。看了一下文档发现原来containsString:是从iOS 8才加入的，iOS 7 SDK并没有该方法。这个问题解决起来也挺简单的，在iOS 7下可以用如下代码代替containsString:方法： 1BOOL isContained = [aString rangeOfString:bString].location != NSNotFound 不过，我觉得要在每一个需要调用containsString:方法写一遍有点麻烦，把适配的代码抽离出来写入一个方法倒是可以，但我还是觉得有点麻烦，毕竟懒癌患者。于是，我想到了用runtime运行时机制动态添加containsString:方法就可以一劳永逸了。实现的原理也很简单，在iOS 7下判断NSString中是否存在containsString:实例方法，若不存在，则动态添加该方法。这样就不用再需要调用containsString:实例方法去判断了。原理很简单，代码也很简单，还是很符合我这个懒癌患者的口味的嘛。","text":"最近做项目过程中版本适配到iOS 7上出现了一点问题，定位分析了一下发现原来是NSstring的containsString:方法在从中作梗。看了一下文档发现原来containsString:是从iOS 8才加入的，iOS 7 SDK并没有该方法。这个问题解决起来也挺简单的，在iOS 7下可以用如下代码代替containsString:方法： 1BOOL isContained = [aString rangeOfString:bString].location != NSNotFound 不过，我觉得要在每一个需要调用containsString:方法写一遍有点麻烦，把适配的代码抽离出来写入一个方法倒是可以，但我还是觉得有点麻烦，毕竟懒癌患者。于是，我想到了用runtime运行时机制动态添加containsString:方法就可以一劳永逸了。实现的原理也很简单，在iOS 7下判断NSString中是否存在containsString:实例方法，若不存在，则动态添加该方法。这样就不用再需要调用containsString:实例方法去判断了。原理很简单，代码也很简单，还是很符合我这个懒癌患者的口味的嘛。12345678910111213// NSString+containsStringCategory.h#import &lt;Foundation/Foundation.h&gt;#if __IPHONE_OS_VERSION_MIN_REQUIRED &lt; 80000@interface NSString (containsStringCategory)- (BOOL)containsString:(NSString *)str;@end#endif 1234567891011121314151617181920212223242526272829// NSString+containsStringCategory.m#import &quot;NSString+containsStringCategory.h&quot;#import &lt;objc/runtime.h&gt;#if __IPHONE_OS_VERSION_MIN_REQUIRED &lt; 80000@implementation NSString (containsStringCategory)+ (void)load&#123; @autoreleasepool &#123; [self zs_modernizeSelector:@selector(containsString:) withSelector:@selector(zs_containsString:)]; &#125;&#125;+ (void)zs_modernizeSelector:(SEL)originSelector withSelector:(SEL)newSelector&#123; if (![NSString instancesRespondToSelector:originSelector]) &#123; Method newMethod = class_getInstanceMethod(self, newSelector); class_addMethod(self, originSelector, method_getImplementation(newMethod), method_getTypeEncoding(newMethod)); &#125;&#125;- (BOOL)zs_containsString:(NSString *)str&#123; return [self rangeOfString:str].location != NSNotFound;&#125;@end#endif","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"UIImage加载图片方式的研究","slug":"UIImage加载图片方式的研究","date":"2016-01-20T11:56:39.000Z","updated":"2016-08-30T13:19:34.000Z","comments":true,"path":"2016/01/20/UIImage加载图片方式的研究/","link":"","permalink":"http://yoursite.com/2016/01/20/UIImage加载图片方式的研究/","excerpt":"常用的UIImage加载图片的方式有以下几种： [UIImage imageNamed:name] [UIImage imageWithContentsOfFile:name] [UIImage imageWithData:data] [UIImage imageWithCGImage:imageRef] [UIImage imageWithCIImage:obj] 以上方法中imageNamed:和imageWitData:应用程序会对其自动缓存，不过，它们缓存的实现方式并不相同，后面会有详细说明。除去这两个方法以外剩下的三个方法默认情况下是不会产生缓存的，这三个方法的主要区别在于它们的数据源：imageWithContentsOfFile:从指定文件中创建对象，imageWithCGImage:以CGImageRef来创建对象，imageWithCIImage:以CIImage对象来创建对象。最后两种方法平时用的相对会少一些，简要解释一下CGImage与CIImage的区别：CGImageRef只能代表位图，如果你需要与bitmap数据打交道，无疑CGImage是非常合适的选择。CGImageRef以CG开头就不难想到CGImageRef的相关操作都需要在Core Graphics中进行，比如混合、遮罩等等。CIImage以CI开头，即Core Image，不难理解CIImage是底层的数据对象，它通常包含了与它相关的图像数据，而不是一个图像。默认情况下，CIImage对象是不会被绘图系统渲染的，除非是得到明确的指令。这种机制（“lazy evaluation”）允许核心绘图系统尽可能高效地运行。CIImage通常被运用在GPU优化图像滤镜算法当中。","text":"常用的UIImage加载图片的方式有以下几种： [UIImage imageNamed:name] [UIImage imageWithContentsOfFile:name] [UIImage imageWithData:data] [UIImage imageWithCGImage:imageRef] [UIImage imageWithCIImage:obj] 以上方法中imageNamed:和imageWitData:应用程序会对其自动缓存，不过，它们缓存的实现方式并不相同，后面会有详细说明。除去这两个方法以外剩下的三个方法默认情况下是不会产生缓存的，这三个方法的主要区别在于它们的数据源：imageWithContentsOfFile:从指定文件中创建对象，imageWithCGImage:以CGImageRef来创建对象，imageWithCIImage:以CIImage对象来创建对象。最后两种方法平时用的相对会少一些，简要解释一下CGImage与CIImage的区别：CGImageRef只能代表位图，如果你需要与bitmap数据打交道，无疑CGImage是非常合适的选择。CGImageRef以CG开头就不难想到CGImageRef的相关操作都需要在Core Graphics中进行，比如混合、遮罩等等。CIImage以CI开头，即Core Image，不难理解CIImage是底层的数据对象，它通常包含了与它相关的图像数据，而不是一个图像。默认情况下，CIImage对象是不会被绘图系统渲染的，除非是得到明确的指令。这种机制（“lazy evaluation”）允许核心绘图系统尽可能高效地运行。CIImage通常被运用在GPU优化图像滤镜算法当中。 UIImage缓存原理1.[UIImage imageNamed:name]我通过查看imageNamed方法的调用栈以及查阅苹果相关文档后对UIImage的缓存实现有了清晰的认识。当调用imageNamed方法时，该方法会去内存缓存里去查找与参数一致的image对象并且返回最合适大小的image对象，如果没有找到，该方法则会去本地磁盘中查找然后加载图片并返回image对象，同时将image对象缓存到系统缓存中，以便下次重复使用。更底层一点的解释，当返回image对象时，并未对image的图片数据进行解码。它的解码过程发生在UIImage对象第一次显示到屏幕上的时候，而image对象的缓存也发生在这时候。当解码完成image显示在屏幕上后，应用程序会将image的解码结果保存到缓存中。通常缓存会在收到内存警告时才会被清空。 2.[UIImage imageWithData:data]在查看imageWithData方法的调用栈时发现了有意思的东西。通过二进制数据创建image对象时，实际上在底层调用的是ImageIO/ImageIO.h的CGImageSourceCreateWithData()方法。该方法的第二个参数可以传入key为kCGImageSourceShouldCache的键值对，它的值是CFBooleanRef类型的，默认情况下，在64位机器上它的值为kCFBooleanTrue，而在32位机器上它的值为kCFBooleanFalse。也就是说在64位机器上是会缓存的，而在32位机器上则是不会缓存的。与imageNamed方法类似，图片会在第一次显示到屏幕上时才会进行解码，随后再被缓存到CGImage里面。依据是CGImageSourceCreateWithData()方法第二个参数可以传入key为kCGImageSourceShouldCacheImmediately的键值对，默认情况下它的值是kCFBooleanFalse。 UIImage不缓存 [UIImage imageWithContentsOfFile:name]与前面两个方法略有不同，该方法是同步的（synchronous）。当在主线程（UI）中调用该方法时，会阻塞主线程并从磁盘中加载图片数据，若磁盘数据较大会造成卡顿或者延迟。通常的解决方法是另开一个线程异步完成磁盘加载图片数据的任务，然后在主线程中刷新UI。下面代码给出了一个例子： 123456789dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123; UIImage *image = [UIImage imageWithContentsOfFile:imagePath]; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.button setBackgroundImage:image forState:UIControlStateNormal]; &#125;);&#125;); 当图片显示在屏幕上时，系统并不会对其进行缓存。当图片数据被加载到内存中，它会被标记为可清除（purgeable）。如果数据被清除了且需要再次加载，image对象会再次从指定的文件路径获取数据并加载进内存中。根据它的实现原理，通常该方法的使用场景是图片不需要重复展示，或者图片的数据较大会造成内存警告。当然，这并不是说imageWithContentsOfFile:一定比imageNamed:方法高效，imageWithContentsOfFile:方法的问题在于它会将图片文件全尺寸展示在屏幕上即使是512*512的图片都要占到1M多的内存，加载会影响程序的性能，造成不好的用户体验。针对图片尺寸太大带来的性能问题，比较好的解决方案是用CGImageSource的有关方法，将图片的尺寸缩减到适合的尺寸，减小数据大小。123456789101112131415161718192021#import &lt;ImageIO/ImageIO.h&gt;NSURL *imageFileURL = [NSURL fileURLWithPath:...];CGImageSourceRef imageSource = CGImageSourceCreateWithURL((CFURLRef)imageFileURL, NULL);if (imageSource == NULL) &#123; // Error loading image ... return;&#125;NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithBool:NO], (NSString *)kCGImageSourceShouldCache, nil];CFDictionaryRef imageProperties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, (CFDictionaryRef)options);if (imageProperties) &#123; NSNumber *width = (NSNumber *)CFDictionaryGetValue(imageProperties, kCGImagePropertyPixelWidth); NSNumber *height = (NSNumber *)CFDictionaryGetValue(imageProperties, kCGImagePropertyPixelHeight); NSLog(@&quot;Image dimensions: %@ x %@ px&quot;, width, height); CFRelease(imageProperties);&#125;CFRelease(imageSource);","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"ApplePay线上支付教程","slug":"ApplePay线上支付教程","date":"2016-01-14T12:33:39.000Z","updated":"2016-08-30T13:19:27.000Z","comments":true,"path":"2016/01/14/ApplePay线上支付教程/","link":"","permalink":"http://yoursite.com/2016/01/14/ApplePay线上支付教程/","excerpt":"第一部分 准备阶段1）硬件要求：iPhone6及更新的设备，还有iPad air2和iPad mini3之后的平板，以及apple watch。具体型号（截止2016年2月）：iPhone 6，iPhone 6 Plus，iPhone 6s， iPhone 6s Plus；iPad Air 2，iPad mini 3，iPad mini 4，iPad Pro；还有Apple Watch。 2）系统要求：iPhone或iPad至少要升到iOS 9.2版，手表至少watch OS 2.1。 3）配置支付环境1.进入苹果开发者中心，注册App ID。App ID必须是explicit类型，否则无法使用ApplePay服务。","text":"第一部分 准备阶段1）硬件要求：iPhone6及更新的设备，还有iPad air2和iPad mini3之后的平板，以及apple watch。具体型号（截止2016年2月）：iPhone 6，iPhone 6 Plus，iPhone 6s， iPhone 6s Plus；iPad Air 2，iPad mini 3，iPad mini 4，iPad Pro；还有Apple Watch。 2）系统要求：iPhone或iPad至少要升到iOS 9.2版，手表至少watch OS 2.1。 3）配置支付环境1.进入苹果开发者中心，注册App ID。App ID必须是explicit类型，否则无法使用ApplePay服务。 2.勾选Apple Pay并点击continue，然后点击“submit”提交。 3.在App IDs中找到刚刚注册成功的App ID，点击edit，对Apple Pay进行配置。 4.创建MerchantID。 5.配置Apple Pay服务，勾选Merchant ID。 6.App ID的apple pay选项变成enable表示配置成功。 7.创建Xcode项目，填入刚注册的BundleID。 8.在项目的target-&gt;Capabilities中，打开Apple Pay，并勾选Merchant ID。 第二部分 代码实现项目地址：https://github.com/ZakariyyaSv/ApplePayDemo 一、判断支付环境1.导入Passkit框架，加载view。1#import &lt;PassKit/PassKit.h&gt; 2.判断当前设备是否支持Apple Pay以及wallet中是否有符合所支持网络的银行卡。1234567891011121314151617181920// 1.判断当前设备是否支持ApplePayif ([PKPaymentAuthorizationViewController canMakePayments]) &#123; // 2.判断是否添加了银行卡 if ([PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:@[PKPaymentNetworkChinaUnionPay]]) &#123; // 3.1添加支付按钮，点击跳转去支付 PKPaymentButton *buyBtn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeBuy style:PKPaymentButtonStyleBlack]; [buyBtn addTarget:self action:@selector(buyOnClick) forControlEvents:UIControlEventTouchUpInside]; [self.payView addSubview:buyBtn]; &#125; else &#123; // 3.2添加设置按钮，点击跳转去wallet绑定银行卡 PKPaymentButton *setupBtn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeSetUp style:PKPaymentButtonStyleWhiteOutline]; [setupBtn addTarget:self action:@selector(jumpToWallet) forControlEvents:UIControlEventTouchUpInside]; [self.payView addSubview:setupBtn]; &#125;&#125;else &#123; NSLog(@&quot;The device cannot support ApplePay!&quot;);&#125; 运行效果如下图所示： 3.若wallet中没有绑定所支持网络的银行卡，则点击按钮跳转到wallet中去绑定银行卡。1234- (void)jumpToWallet&#123; PKPassLibrary *walletLibrary = [[PKPassLibrary alloc] init]; [walletLibrary openPaymentSetup];&#125; 4.若该设备支持Apple Pay并且有绑定所支持网络的银行卡则发起支付请求。12345678910111213141516171819202122232425- (void)buyOnClick&#123; NSLog(@&quot;start to pay!&quot;); // 创建支付请求，配置请求信息。 PKPaymentRequest *payRequest = [[PKPaymentRequest alloc] init]; // 国家代码 payRequest.countryCode = @&quot;CN&quot;; // 货币代码 payRequest.currencyCode = @&quot;CNY&quot;; // 商家ID payRequest.merchantIdentifier = @&quot;merchant.com.zakariyya.fabrunMerchant&quot;; // 商家的处理方式 payRequest.merchantCapabilities = PKMerchantCapability3DS; // 商家支持的网络 payRequest.supportedNetworks = @[PKPaymentNetworkChinaUnionPay]; // 配置支付订单的详情 PKPaymentSummaryItem *cameraItem = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;单反相机&quot; amount:[NSDecimalNumber decimalNumberWithString:@&quot;5999.0&quot;] type:PKPaymentSummaryItemTypeFinal]; PKPaymentSummaryItem *totalItem = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;佳能&quot; amount:[NSDecimalNumber decimalNumberWithString:@&quot;5999.0&quot;] type:PKPaymentSummaryItemTypeFinal]; payRequest.paymentSummaryItems = @[cameraItem,totalItem]; // 跳转并验证支付权限 PKPaymentAuthorizationViewController *authViewController = [[PKPaymentAuthorizationViewController alloc] initWithPaymentRequest:payRequest]; authViewController.delegate = self; [self presentViewController:authViewController animated:YES completion:nil];&#125; 支付请求配置包括国家代码、货币代码、商家ID、商家的处理方式、商家支持的网络、订单的详情，这几个要素缺一不可。其中，merchantCapabilities是一个枚举值：123456typedef NS_OPTIONS(NSUInteger, PKMerchantCapability) &#123; PKMerchantCapability3DS = 1UL &lt;&lt; 0, // Merchant supports 3DS PKMerchantCapabilityEMV = 1UL &lt;&lt; 1, // Merchant supports EMV PKMerchantCapabilityCredit NS_ENUM_AVAILABLE_IOS(9_0) = 1UL &lt;&lt; 2, // Merchant supports credit PKMerchantCapabilityDebit NS_ENUM_AVAILABLE_IOS(9_0) = 1UL &lt;&lt; 3 // Merchant supports debit&#125; NS_ENUM_AVAILABLE(NA, 8_0); 这些枚举值当中PKMerchantCapability3DS是必选项，其他的则是可选项。 supportedNetworks是一个包含常量字符串的数组：1234567extern NSString * const PKPaymentNetworkAmex NS_AVAILABLE(NA, 8_0);extern NSString * const PKPaymentNetworkChinaUnionPay NS_AVAILABLE(NA, 9_2);extern NSString * const PKPaymentNetworkDiscover NS_AVAILABLE(NA, 9_0);extern NSString * const PKPaymentNetworkInterac NS_AVAILABLE(NA, 9_2);extern NSString * const PKPaymentNetworkMasterCard NS_AVAILABLE(NA, 8_0);extern NSString * const PKPaymentNetworkPrivateLabel NS_AVAILABLE(NA, 9_0);extern NSString * const PKPaymentNetworkVisa NS_AVAILABLE(NA, 8_0); 国内一般我们用到的会是中国银联，即PKPaymentNetworkChinaUnionPay，注意：iOS 9.2以后才开始支持银联支付。 5.监听用户授权状态1234567891011121314151617181920#pragma mark - PKPaymentAuthorizationViewControllerDelegate// 用户授权成功后调用此方法- (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller didAuthorizePayment:(PKPayment *)payment completion:(void (^)(PKPaymentAuthorizationStatus))completion&#123; // 一般在此处，拿到支付信息，发送给服务端处理，处理完毕后，服务器会返回一个状态来告诉客户端是否支付成功，然后由客户端进行处理。 BOOL isSuccess = YES; if (isSuccess) &#123; completion(PKPaymentAuthorizationStatusSuccess); &#125; else &#123; completion(PKPaymentAuthorizationStatusFailure); &#125;&#125;// 用户授权成功或者用户取消授权操作时调用该方法- (void)paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller&#123; NSLog(@&quot;Authorization did finished!&quot;); [self dismissViewControllerAnimated:YES completion:nil];&#125; 附：","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"UIButton之titleLabel、imageView解析","slug":"UIButton之titleLabel、imageView解析","date":"2015-12-28T02:28:19.000Z","updated":"2016-09-13T12:29:45.000Z","comments":true,"path":"2015/12/28/UIButton之titleLabel、imageView解析/","link":"","permalink":"http://yoursite.com/2015/12/28/UIButton之titleLabel、imageView解析/","excerpt":"UIButton是我们开发过程中使用频率很高的控件类。在使用UIButton实现需求时，通常会碰到需要改变UIButton中image和title位置和大小的需求。如果对UIButton中的titleLabel和imageView理解不到位的话，只能是不停地修改参数，不停地调试，陷入恶性循环，既低效又很难正确地去实现。为了解决这个问题，我研究出了两套方案，分别是用imageEdgeInsets、titleEdgeInsets组合的方案以及imageRectContentRet、titleRectContentRect组合的方案。","text":"UIButton是我们开发过程中使用频率很高的控件类。在使用UIButton实现需求时，通常会碰到需要改变UIButton中image和title位置和大小的需求。如果对UIButton中的titleLabel和imageView理解不到位的话，只能是不停地修改参数，不停地调试，陷入恶性循环，既低效又很难正确地去实现。为了解决这个问题，我研究出了两套方案，分别是用imageEdgeInsets、titleEdgeInsets组合的方案以及imageRectContentRet、titleRectContentRect组合的方案。 titleEdgeInsets、imageEdgeInsets组合这个方案是使用的比较多的解决方案，它主要依赖的是两个方法： titleEdgeInsets imageEdgeInsets 这个方案比较麻烦的地方在于很多人对这两个方法的理解不到位，导致使用的时候设置和显示的效果不一致。UIButton继承自UIControl，它因此也继承了两个属性contentVerticalAlignment和contentHorizontalAlignment。这两个属性是用来排列内部元素的,默认值都是Center，先看下它们的定义：12345678910111213typedef NS_ENUM(NSInteger, UIControlContentVerticalAlignment) &#123; UIControlContentVerticalAlignmentCenter = 0, UIControlContentVerticalAlignmentTop = 1, UIControlContentVerticalAlignmentBottom = 2, UIControlContentVerticalAlignmentFill = 3,&#125;;typedef NS_ENUM(NSInteger, UIControlContentHorizontalAlignment) &#123; UIControlContentHorizontalAlignmentCenter = 0, UIControlContentHorizontalAlignmentLeft = 1, UIControlContentHorizontalAlignmentRight = 2, UIControlContentHorizontalAlignmentFill = 3,&#125;; 按照4*4的组合分为16种选择结果。为了在计算过程中更方便点，我通常选择UIControlContentVerticalAlignmentTop、UIControlContentHorizontalAlignmentLeft的组合，这样符合我们以左上角作为坐标原点布局的思维。这里要纠正几个误区：第一，edgeinsets只是相对于当前位置的偏移量，并不是指距离UIButton边界的距离；第二，在同时存在图片还有文字的时候，只有UIButton的contentRect的宽度大于image和title的宽度才能正确显示，否则，文字由于无法进行拉伸收缩的原因只能显示…或者图片被压缩；第三、imageView的宽高都能被压缩，titleLabel的宽只能压缩不能拉伸，titleLabel的高只能拉伸不能压缩。 采用left-top方案初始情况下，image和title的位置如下图所示： 在初始状态下，imageEdgeInsets和titleEdgeInsets均为0，因此在计算偏移量的时候，image的top、left、right、bottom以及title的top、bottom、right均能以button的边界作为参考，而title的left是以image的left为参考的。搞清楚了之后，来做一下image在上，title在下的button：123456789CGFloat imageTop = (button.height-image.height-title.height) / 2;CGFloat titleTop = imageTop+image.height;CGFloat imageLeft = (button.width-image.width) / 2;// 这里减了image.width，因为title的left是以image的left为参考CGFloat titleLeft = (button.width-title.widht) / 2 - image.width;button.imageEdgeInsets = UIEdgeInsetsMake(imageTop, imageLeft, 0, 0);button.titleEdgeInsets = UIEdgeInsetsMake(titleTop, titleLeft, 0, 0); 这里还牵扯到一个问题，有人可能会觉得既然有left和top，那就不需要right和bottom了，实际不然。这实际上是涉及到约束的优先级。其定义如下： top-left-bottom-right取负值 &gt; 不能超出button边界 &gt; imageView不能被压缩 top-left-bottom-right取负值 &gt; 不能超出button边界 &gt; titleLabel水平方向不能被压缩 titleLabel垂直方向不能被压缩 &gt; 不能超出button边界 若有人运用发现image超出button边界，只需要同时调整contentEdgeInsets即可。 imageRectForContentRect、titleRectForContentRect组合第一个方案理解之后确实可以解决问题，不过，我觉得有些麻烦，就想着能不能有更方便的方案。于是，我翻阅文档和资料后，找到了更简单的方案，也就是这第二个方案。 第二个方案涉及到两个方法： (CGRect)titleRectForContentRect:(CGRect)contentRect (CGRect)imageRectForContentRect:(CGRect)contentRect 根据文档的解释，这两个方法返回值是矩形区域，区域内则是用来绘制image和title，返回值的参照系都是UIButton。要想自定义image和title在UIButton的位置和大小，只需要继承UIButton，重写这两个方法即可。 相比第一个方案，第二个方案确实方便不少，但是又有一个问题。要是想改变一个UIButton都得继承UIButton重写方法显得太麻烦，实际上并没有达到简便的目的。于是，我想能不能用runtime运行时机制，给UIButton添加两个变量，直接设置就可以修改image和title在UIButton中的rect，这样会方便很多。 先贴上实现代码： 12345678910111213// UIButton+RectOfImageAndTitle.h#import &lt;UIKit/UIKit.h&gt;@interface UIButton (RectOfImageAndTitle)@property (nonatomic,assign) CGRect btn_contentRect;@property (nonatomic,assign) CGRect btn_imageRect;@property (nonatomic,assign) CGRect btn_titleRect;@end 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// UIButton+RectOfImageAndTitle.m#import &quot;UIButton+RectOfImageAndTitle.h&quot;#import &lt;objc/runtime.h&gt;static const char *btn_contentKey = &quot;btn_contentKey&quot;;static const char *btn_imageKey = &quot;btn_imageKey&quot;;static const char *btn_titleKey = &quot;btn_titleKey&quot;;@implementation UIButton (RectOfImageAndTitle)+ (void)load&#123; @autoreleasepool &#123; [self exchangeIMPWithOriginSelector:@selector(contentRectForBounds:) newSelector:@selector(zs_contentRectForBounds:)]; [self exchangeIMPWithOriginSelector:@selector(imageRectForContentRect:) newSelector:@selector(zs_imageRectForContentRect:)]; [self exchangeIMPWithOriginSelector:@selector(titleRectForContentRect:) newSelector:@selector(zs_titleRectForContentRect:)]; &#125;&#125;+ (void)exchangeIMPWithOriginSelector:(SEL)originSeletor newSelector:(SEL)newSelector&#123; if ([UIButton instancesRespondToSelector:originSeletor]) &#123; Method oriMethod = class_getInstanceMethod(self, originSeletor); Method newMethod = class_getInstanceMethod(self, newSelector); method_exchangeImplementations(oriMethod, newMethod); &#125;&#125;#pragma mark - getter &amp; setter- (void)setBtn_contentRect:(CGRect)btn_contentRect&#123; objc_setAssociatedObject(self, &amp;btn_contentKey, [NSValue valueWithCGRect:btn_contentRect], OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (CGRect)btn_contentRect&#123; if (!objc_getAssociatedObject(self, &amp;btn_contentKey)) &#123; objc_setAssociatedObject(self, &amp;btn_contentKey, [NSValue valueWithCGRect:CGRectZero], OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; return [objc_getAssociatedObject(self, &amp;btn_contentKey) CGRectValue];&#125;- (void)setBtn_imageRect:(CGRect)btn_imageRect&#123; objc_setAssociatedObject(self, &amp;btn_imageKey, [NSValue valueWithCGRect:btn_imageRect], OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (CGRect)btn_imageRect&#123; if (!objc_getAssociatedObject(self, &amp;btn_imageKey)) &#123; objc_setAssociatedObject(self, &amp;btn_imageKey, [NSValue valueWithCGRect:CGRectZero], OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; return [objc_getAssociatedObject(self, &amp;btn_imageKey) CGRectValue];&#125;- (void)setBtn_titleRect:(CGRect)btn_titleRect&#123; objc_setAssociatedObject(self, btn_titleKey, [NSValue valueWithCGRect:btn_titleRect], OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (CGRect)btn_titleRect&#123; return objc_getAssociatedObject(self, btn_titleKey) == nil ? CGRectZero : [objc_getAssociatedObject(self, btn_titleKey) CGRectValue];&#125;#pragma mark - private method- (CGRect)zs_contentRectForBounds:(CGRect)contentRect&#123; if (CGRectEqualToRect(self.btn_contentRect, CGRectZero)) &#123; return [self zs_contentRectForBounds:self.bounds]; &#125; else &#123; return self.btn_contentRect; &#125;&#125;- (CGRect)zs_imageRectForContentRect:(CGRect)contentRect&#123; if (CGRectEqualToRect(self.btn_imageRect, CGRectZero)) &#123; return [self zs_imageRectForContentRect:self.bounds]; &#125; else &#123; return self.btn_imageRect; &#125;&#125;- (CGRect)zs_titleRectForContentRect:(CGRect)contentRect&#123; if (CGRectEqualToRect(self.btn_titleRect, CGRectZero)) &#123; return [self zs_titleRectForContentRect:self.bounds]; &#125; else &#123; return self.btn_titleRect; &#125;&#125;@end 简要说下实现的思路：由于在category中重写imageRectForContentRect、titleRectForContentRect会覆盖原来的方法实现，并且无法使用super关键字，因此重写方法行不通。转而我采用自己实现两个方法并分别与这两个方法的实现进行交换，这样就不会破坏原有方法的实现。此外，动态添加三个实例变量可以直接在实例对象中直接设置来调用imageRectForContentRect、titleRectForContentRect两个方法。 使用的时候导入头文件，再相应的设置一下实例变量就可以达到效果，有没有很方便。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]}]}