{"meta":{"title":"zakariyyaSv's Blog","subtitle":null,"description":"Just Forcus","author":"zakariyyaSv","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2016-08-30T13:07:24.000Z","updated":"2016-08-30T13:08:58.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"iOS","date":"2016-08-30T12:56:19.000Z","updated":"2016-08-30T12:56:19.000Z","comments":true,"path":"iOS/index.html","permalink":"http://yoursite.com/iOS/index.html","excerpt":"","text":""}],"posts":[{"title":"拆解ARC下的self","slug":"拆解ARC下的self","date":"2016-08-24T13:23:28.000Z","updated":"2016-08-30T13:18:49.000Z","comments":true,"path":"2016/08/24/拆解ARC下的self/","link":"","permalink":"http://yoursite.com/2016/08/24/拆解ARC下的self/","excerpt":"最近在研究AFNetworking源码的过程中碰到了很多处地方用到了weakSelf和strongSelf。依据自己之前的理解，正常情况下使用weakSelf是为了避免发生循环引用，而使用strongSelf是为了避免方法还没有执行完成self已经被释放从而导致崩溃。不过为何在方法执行完成之前无法确保self不被释放却不是很明白，于是乎，自己花了些时间研究了一下。 self的本质self是类的隐藏参数，在类方法中self指向当前调用方法的类，在实例方法中指向当前调用方法的类的init方法族生成的实例。更准确来说，在类方法中self是const Class self，在实例方法中self是Person const* self（以Person类举例）。事实确实如此么？来验证一下。","text":"最近在研究AFNetworking源码的过程中碰到了很多处地方用到了weakSelf和strongSelf。依据自己之前的理解，正常情况下使用weakSelf是为了避免发生循环引用，而使用strongSelf是为了避免方法还没有执行完成self已经被释放从而导致崩溃。不过为何在方法执行完成之前无法确保self不被释放却不是很明白，于是乎，自己花了些时间研究了一下。 self的本质self是类的隐藏参数，在类方法中self指向当前调用方法的类，在实例方法中指向当前调用方法的类的init方法族生成的实例。更准确来说，在类方法中self是const Class self，在实例方法中self是Person const* self（以Person类举例）。事实确实如此么？来验证一下。 12345678910111213141516#import &quot;Person.h&quot;@implementation Person- (void)eat&#123;&#125;+ (void)classEat&#123;&#125;- (void)drink:(NSString *)sth&#123; [self eat];&#125;@end 将Person.m用clang命令进行重写，得到的代码如下： 12345678910static void _I_Person_eat(Person * self, SEL _cmd) &#123; id obj = ((Person *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;Person&quot;))&#125;, sel_registerName(&quot;init&quot;));&#125;static void _C_Person_classEat(Class self, SEL _cmd) &#123;&#125;static void _I_Person_drink_(Person * self, SEL _cmd, NSString *sth) &#123; ((void (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(&quot;eat&quot;));&#125; 从重写后的代码中可以看出结论是正确的，但还是没有找到self在方法执行过程中可能被释放的原因。我又查阅了Clang的官方文档,找到了其中关于self的说明： The self parameter variable of an Objective-C method is never actually retained by the implementation. It is undefined behavior, or at least dangerous, to cause an object to be deallocated during a message send to that object. To make this safe, for Objective-C instance methods self is implicitly const unless the method is in the init family. Further, self is always implicitly const within a class method. 翻译过来就是在OC方法中作为参数的self不会被方法的实现持有，当给self指向的对象发送消息时确实可能会发生错误。为了确保安全，除非是在init及类init的方法中，否则在OC的实例方法和类方法中self始终是指针常量无法被retain。根据我的理解整理如下： 在ARC中，self的修饰符是unsafe_unretained，而不是strong。unsafe_unretained与weak类似，均是对对象的弱引用，区别在于当unsafe_unretained的指针指向的对象被释放后，指针仍会指向被释放对象的内存地址，变成野指针导致crash，而当weak的指针指向的对象被释放后，指针指向的对象会被置为nil。正是由于unsafe_unretained修饰符的作用，因此会导致在方法执行的过程若self被释放则会引起crash。 OC方法不会对self自动retain（除了init方法族以外），self在方法运行过程中的生命周期需要由程序员自己手动实现来保证。通常的做法也就是在方法中添加一个局部变量strongSelf来对self指向的对象进行强引用来保证在方法执行完之前self都不会被释放。 对self采用__unsafe_unretained修饰符，主要是为了性能方面的考虑。通常调用一个方法被runtime改写成objc_msgSend()后，传入的第一个参数都是self，从上面clang重写的代码中也可以看出。若是在方法调用中对self进行retain和release，确实可以保证方法执行过程中self不会被释放，但是，会对性能产生很大影响。并且在大多数方法调用过程中，self是不会被释放的，因此，不对self进行reatain和release操作所带来的性能提升是值得的。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"Mac workflow小记","slug":"Mac workflow小记","date":"2016-03-12T12:11:39.000Z","updated":"2016-08-31T12:36:47.000Z","comments":true,"path":"2016/03/12/Mac workflow小记/","link":"","permalink":"http://yoursite.com/2016/03/12/Mac workflow小记/","excerpt":"在Mac平台下做开发也有一段时间了，虽然说相对于windows平台而言，Mac下的软件资源并不如windows下的那么丰富，但是在适应以及找到合适的软件后，我觉得Mac对我而言更适合做开发。对于开发人员来说，效率至上是毋庸置疑的，因此，拥有一套提升效率的软件和工具对于开发人员来说是至关重要的。这篇博客就记录下我自己开发的workflow，也希望通过这篇博客能与他人分享。 Homebrew Homebrew之于Mac的关系就跟apt之于Linux的关系是一样的，它实际上是Mac下的套件管理器。比如你想安装MySQL、git等等工具软件，都可以使用homebrew来下载和管理。homebrew的安装也非常方便，你可以去到它的官网，根据提示进行安装。安装成功后就使用homebrew的命令去下载和管理你需要的工具软件了。","text":"在Mac平台下做开发也有一段时间了，虽然说相对于windows平台而言，Mac下的软件资源并不如windows下的那么丰富，但是在适应以及找到合适的软件后，我觉得Mac对我而言更适合做开发。对于开发人员来说，效率至上是毋庸置疑的，因此，拥有一套提升效率的软件和工具对于开发人员来说是至关重要的。这篇博客就记录下我自己开发的workflow，也希望通过这篇博客能与他人分享。 Homebrew Homebrew之于Mac的关系就跟apt之于Linux的关系是一样的，它实际上是Mac下的套件管理器。比如你想安装MySQL、git等等工具软件，都可以使用homebrew来下载和管理。homebrew的安装也非常方便，你可以去到它的官网，根据提示进行安装。安装成功后就使用homebrew的命令去下载和管理你需要的工具软件了。注：homebrew的安装程序需要用到Xcode的command line tools。 1234567brew install mysql // 安装MySQLbrew uninstall mysql // 卸载MySQLbrew search mysql // 搜索MySQLbrew upgrade mysql // 更新MySQLbrew list // 显示已经安装的软件列表brew update // 更新homebrewbrew deps mysql // 显示MySQL的包依赖 iTerm2 iTerm2是mac下的替代Terminal的终端工具，可以说iTerm2是Mac下最好的终端工具。它有一些特色功能如下： 标签变色iTerm2 的标签的颜色会变化，以指示该 tab 当前的状态。当该标签有新输出的时候，标签会变成洋红色；新的输出长时间没有查看，标签会变成红色。可在设置中关掉该功能。 智能选中在 iTerm2 中，双击选中，三击选中整行，四击智能选中（智能规则可配置），可以识别网址，引号引起的字符串，邮箱地址等。（很多时候双击的选中就已经很智能了）在 iTerm2 中，选中即复制。即任何选中状态的字符串都被放到了系统剪切板中。 巧用 Command 键按住⌘键:可以拖拽选中的字符串；点击 url：调用默认浏览器访问该网址；点击文件：调用默认程序打开文件；如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行；点击文件夹：在 finder 中打开该文件夹；同时按住option键，可以以矩形选中，类似于vim中的ctrl v操作。 iTerm2的可定制化也是一大特色，详细的定制化步骤可以参见我的另一篇博客。 Alfred3 我对Alfred3的评价是Mac下最逆天的工具。如果你是个键盘党，Alfred绝对可以让你基本摆脱鼠标。丰富的workflow可以让你的操作变得得心应手而且高效。你可以去alfredworkflow上下载安装适合你的workflow。当然，你要是想自己制作workflow也很容易，简单易上手，这也是Alfred workflow资源丰富的原因所在。如果兜里不差钱还是建议去买个终身会员，绝对值得。如果囊中羞涩，这里提供一个破解版本供大家尝鲜。（下载链接） Dash Dash是Mac下的API文档查阅器，其储存了超过150种API离线文档。这可以说是程序员必备利器，不管是从操作体验以及资源的丰富程度都是Mac平台下最好用的。同时，配合Alfred使用，效率会更高。Dash提供免费版也带有付费插件，如果不差钱，支持一下也是无可厚非的。 CheatSheet CheatSheet是一款Mac上非常实用的快捷键快速提醒工具，只需要按住Command键，就会弹出当前应用所有的快捷键列表。所以，即使你记不住一些快捷键也没有关系，有CheatSheet就够了。 Sequel Pro Sequel Pro（原CocoaMySQL）是众多Mac程序员使用的MySQL管理软件，提供了比phpmyadmin更强大的管理能力，帮助用户轻松编辑数据库，表（字段和索引）和列，执行个性化查找以及导出/入数据，快速查询数据。 Sequel Pro它最大的优点是简单、易用。因为这款工具是苹果公司为了吸引Web开发者进入Mac平台而投资的项目。所以它处处体现了苹果公司简洁的设计哲学。说它是全世界最好用的MySQL数据库管理工具是一点也不夸张。 功能特点： 支持多达30种编码方式 快速导出/导入、备份/还原数据库的SQL/CSV文件 最高版本支持MySQL 5.6 内置强大的数据库查询编辑器，有自定义查询中的自动语句高亮功能，可自定义字体，自定义查询占位符. 允许你编辑数据库，表格（字段和索引）和列，执行个性化查找和导入导出数据 自动补全关键词，表名，域名 自动段落化查询命令 IP直连数据库 表触发机制 服务器运行监控Query Favourites for SQL reuse 包括检索功能在内的全表管理设计 快速在Mac上架设本地MySQL数据库 在MAMP/XAMP架构上连接数据库 SSH连接模式 Sublime Text 3 Sublime Text可以说是一款优雅高效地编辑器，越来越受到开发人员的欢迎。这款编辑器区别于其他编辑器的特性主要有以下几点： 随时保留文件的修改 多重选择，同时修改 智能选择 智能感知，一键注释 Goto Anything，智能搜索 自动完成，无处不在 HTML标签输入 标签输入，再简化 简单全面的插件体系 Lantern Lantern是一款免费开源的科学上网的软件，安装和使用极其简单。Lantern让用户能流畅地访问被封锁的互联网站点。Lantern自动检测一个网站是否被封锁。对那些被封锁的网站，Lantern通过自有的服务器或者未封锁地区的用户运行的Lantern来提供访问。如果网站没有被封锁，Lantern选择靠边站。这样浏览器就会直接访问网站，而速度不受影响。 iStat Menus iStat Menus 5 是一款由软件开发商 Bjango 制作的 System Monitor（工具，也是笔者电脑里的必装应用之一，它能让用户最快速、最直观地了解到几乎各硬件所有的运行状态，其中包括：CPU 中央处理器、GPU 图形处理器、Memory 虚拟内存、Network 网络、Battery 电池、Disks 硬盘等。 Cmd Markdown编辑器 Cmd Markdown是一款markdown编辑器，相比于同类markdown编辑器，Cmd Markdown编辑器的优势在于对中文支持比较好，实时的云端文稿，实时同步预览等等。 目前，也就只有这些了，后续如果发现好用的软件会继续更新的。","categories":[{"name":"Mac相关","slug":"Mac相关","permalink":"http://yoursite.com/categories/Mac相关/"}],"tags":[],"keywords":[{"name":"Mac相关","slug":"Mac相关","permalink":"http://yoursite.com/categories/Mac相关/"}]},{"title":"深入理解NSMapTable、NSHashTable、NSPointerArray","slug":"深入理解NSMapTable、NSHashTable、NSPointerArray","date":"2016-03-10T02:19:45.000Z","updated":"2016-09-08T13:47:22.000Z","comments":true,"path":"2016/03/10/深入理解NSMapTable、NSHashTable、NSPointerArray/","link":"","permalink":"http://yoursite.com/2016/03/10/深入理解NSMapTable、NSHashTable、NSPointerArray/","excerpt":"最近在学习YYCache中的YYDiskCache时，注意到了这段代码： 12345678910111213141516171819202122232425262728/// weak reference for all instancesstatic NSMapTable *_globalInstances;static dispatch_semaphore_t _globalInstancesLock;static void _YYDiskCacheInitGlobal() &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _globalInstancesLock = dispatch_semaphore_create(1); _globalInstances = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0]; &#125;);&#125;static YYDiskCache *_YYDiskCacheGetGlobal(NSString *path) &#123; if (path.length == 0) return nil; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); id cache = [_globalInstances objectForKey:path]; dispatch_semaphore_signal(_globalInstancesLock); return cache;&#125;static void _YYDiskCacheSetGlobal(YYDiskCache *cache) &#123; if (cache.path.length == 0) return; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); [_globalInstances setObject:cache forKey:cache.path]; dispatch_semaphore_signal(_globalInstancesLock);&#125;","text":"最近在学习YYCache中的YYDiskCache时，注意到了这段代码： 12345678910111213141516171819202122232425262728/// weak reference for all instancesstatic NSMapTable *_globalInstances;static dispatch_semaphore_t _globalInstancesLock;static void _YYDiskCacheInitGlobal() &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _globalInstancesLock = dispatch_semaphore_create(1); _globalInstances = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0]; &#125;);&#125;static YYDiskCache *_YYDiskCacheGetGlobal(NSString *path) &#123; if (path.length == 0) return nil; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); id cache = [_globalInstances objectForKey:path]; dispatch_semaphore_signal(_globalInstancesLock); return cache;&#125;static void _YYDiskCacheSetGlobal(YYDiskCache *cache) &#123; if (cache.path.length == 0) return; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); [_globalInstances setObject:cache forKey:cache.path]; dispatch_semaphore_signal(_globalInstancesLock);&#125; YYDiskCache采用NSMapTable作为全局变量而并没有采用NSDictionary来存储cache变量，这样做的好处是避免_globalInstances与cache发生循环引用，造成内存无法释放。回顾之前自己的编码经历，基本没考虑过NSDictionary与其元素可能发生的循环引用问题，不得不说自己在这方面还是有欠缺。因而写下这篇blog总结这部分的内容。 我在总结的过程中发现了NSMapTable-NSDictionary、NSHashTable-NSSet、NSPointerArray-NSArray三组存在相似的关系，于是我就想干脆将这几个类总结在一起，便于理解。 NSMapTable - NSDictionary以下是苹果文档关于NSMapTable的描述： The NSMapTable class is a mutable collection modeled after NSDictionary, with the following differences: The major option is to have keys and/or values held “weakly” in a manner that entries are removed when one of the objects is reclaimed. Its keys or values may be copied on input or may use pointer identity for equality and hashing. It can contain arbitrary pointers (its contents are not constrained to being objects). 总结一下，NSMapTable仿效的是NSDictionary，但它是可变的集合。它与NSDictionary有几点区别： 1.NSMapTable与NSDictionary最重要的区别在于前者可以将keys和values以弱引用的方式关联，当其中任一对象被回收了，其所有的内容都会被移除。我们可以通过mapTableWithKeyOptions:valueOptions:分别控制键和值的对象获取/保留行为。NSDictionary则会对keys和values执行retain操作，只有等到NSDictionary被release才会release它所持有的keys和values。 NSMapTable可以包含任意的指针并且指针的内容不限定必须是对象，然后用指针去做相等或者hasing检查，而NSDictionary的key必须是遵循NSCopying协议的对象。不仅如此，如果NSDictionary要使用KVC那么key必须是字符串。 当NSMapTable指定为NSMapTableCopyIn，它会通过NSCopying协议将添加进来的数据复制一份副本，NSDictionary则需要调用copy方法来复制数据。 NSHashTable - NSSet以下是苹果文档关于NSHashTable的描述： NSHashTable is modeled after NSSet but provides different options, in particular to support weak relationships. It can hold weak references to its members. Its members may be copied on input or may use pointer identity for equality and hashing. It can contain arbitrary pointers (its members are not constrained to being objects). Because of its options, NSHashTable is not a set because it can behave differently (for example, if pointer equality is specified two isEqual: strings will both be entered). 总结一下，NSHashTable效仿的是NSSet但提供更多不同的选项，尤其是支持weak关联。它支持对所有成员的弱引用，而NSSet对所有成员均是强引用。其他的不同点与前面NSMapTable与NSDictionary类似，可以参考对比，就不再码废话了。 NSPointerArray - NSArray以下是苹果文档关于NSPointerArray的描述： The NSPointerArray class represents a mutable collection modeled after NSArray, but can also hold nil values. nil values may be inserted or removed and contribute to the object’s count. An NSPointerArray object can also increase and decrease its count directly. A pointer array can be initialized to maintain strong or weak references to objects, or according to any of the memory or personality options defined by NSPointerFunctionsOptions. The NSCopying and NSCoding protocols are applicable only when a pointer array is initialized to maintain strong or weak references to objects. When enumerating a pointer array with NSFastEnumeration using for…in, the loop will yield any nil values present in the array. See Fast Enumeration Makes It Easy to Enumerate a Collection in Programming with Objective-C for more information. 总结一下，NSPointerArray效仿的是NSArray，但可以存储值为nil的元素。nil可以被插入和移除并且计入对象的数目中。而NSArray不可以存储nil，通常它会将nil看做数组的终止符，并且不会计入到对象的数目当中。NSPointerArray可以直接增加或减少元素的数量，与NSMutableArray类似。NSPointerArray最重要的特性与前面两组相同，均是可以对存储的对象采用弱引用。只有当NSPointerArray存储的是对象时NSCopying、NSCoding协议才会适用。还有一点要注意的，在快速遍历的for…in方法中，如果NSPointerArray存在nil则循环遍历会终止。 结语依据这三组类的不同也就归纳出它们各自的应用场景。若你的使用场景中可能会产生如实例代码中的循环引用问题，那就使用前者，若你的使用场景中存储的对象不遵循NSCopying协议或者就不是对象，而是指针之类，那就使用前者。其他大多数情况下还是使用后者。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"YYCache源码学习","slug":"YYCache源码学习","date":"2016-03-06T06:17:28.000Z","updated":"2016-09-07T13:10:24.000Z","comments":true,"path":"2016/03/06/YYCache源码学习/","link":"","permalink":"http://yoursite.com/2016/03/06/YYCache源码学习/","excerpt":"这篇文章并不是对YYCache的设计思路的范范分析，而是对YYCache代码实现的详细分析。一方面YYCache的设计思路作者已经写得比较清楚了，我就没必要再多此一举了，有兴趣的可以到大神的博客去看YYCache 设计思路。从代码层面进行分析，一方面是因为很多思路上的东西很虚理解起来大都很容易，但是要能用代码实现却往往不那么轻松，另一方面是因为代码分析可以学习优秀代码的编码风格以及加深对iOS技术上的理解，这样做给自己带来的帮助或许会更多。 代码结构YYCache文件数并不多，主要包含四个文件： YYCache YYDiskCache YYMemoryCache YYKVStorage","text":"这篇文章并不是对YYCache的设计思路的范范分析，而是对YYCache代码实现的详细分析。一方面YYCache的设计思路作者已经写得比较清楚了，我就没必要再多此一举了，有兴趣的可以到大神的博客去看YYCache 设计思路。从代码层面进行分析，一方面是因为很多思路上的东西很虚理解起来大都很容易，但是要能用代码实现却往往不那么轻松，另一方面是因为代码分析可以学习优秀代码的编码风格以及加深对iOS技术上的理解，这样做给自己带来的帮助或许会更多。 代码结构YYCache文件数并不多，主要包含四个文件： YYCache YYDiskCache YYMemoryCache YYKVStorage 他们之间的关系可以用一张图来描述： YYCache是整个缓存框架的核心类，它是由YYDiskCache和YYMemeoryCache组成，而YYDiskCache需要借助YYKVStorage来实现对元素的读写。以下就依次对每个类进行详细的剖析，我觉得由下向上的去看代码理解起来会更方便，于是剖析的顺序依次是YYKVStorage、YYDiskCache、YYMemeoryCache、YYCache。 YYKVStorageYYKVStorage文件中包含两个类YYKVStorageItem和YYKVStorage，前者的作用是为后者提供存储键值对和元数据服务的。前者将每一个储存的数据包装成一个元素，是静态的，后者则是对前者的元素进行读写操作，是动态的。做个比喻，YYKVStorageItem就好比是仓库里的货物，而YYKVStorage则是仓库管理员。不过，该类并非是线程安全的，所以，需要确保该类同一时间只能由一个YYKVStorage对象去访问某个YYKVStorageItem元素。YYKVStorageItem的结构很简单：123456789@interface YYKVStorageItem : NSObject@property (nonatomic, strong) NSString *key; ///&lt; key@property (nonatomic, strong) NSData *value; ///&lt; value@property (nullable, nonatomic, strong) NSString *filename; ///&lt; filename (nil if inline)@property (nonatomic) int size; ///&lt; value&apos;s size in bytes@property (nonatomic) int modTime; ///&lt; modification unix timestamp@property (nonatomic) int accessTime; ///&lt; last access unix timestamp@property (nullable, nonatomic, strong) NSData *extendedData; ///&lt; extended data (nil if no extended data)@end key：唯一标示元素的标识符value：存储的二进制数据filename：存储数据文件的文件名size：限定存储数据的大小modTime：最后一次修改数据的时间戳accessTime：最后一次读取数据的时间戳extendedData：附加的数据 YYKVStorage类的结构如下：123456@interface YYKVStorage : NSObject#pragma mark - Attribute@property (nonatomic, readonly) NSString *path; ///&lt; The path of this storage.@property (nonatomic, readonly) YYKVStorageType type; ///&lt; The type of this storage.@property (nonatomic) BOOL errorLogsEnabled; ///&lt; Set `YES` to enable error logs for debug.@end path：存储的路径type：存储类型errorLogsEnabled：debug下是否打印错误信息注：由于写入速度方面sqlite比文件速度快，但是读取速度方面的性能则取决于数据的大小。在作者的测试当中，当数据大于20KB时，读取速度上文件要快于sqlite。为了从性能方面考虑，加入了YYKVStorageType枚举类型。1234567891011typedef NS_ENUM(NSUInteger, YYKVStorageType) &#123; /// The `value` is stored as a file in file system. YYKVStorageTypeFile = 0, /// The `value` is stored in sqlite with blob type. YYKVStorageTypeSQLite = 1, /// The `value` is stored in file system or sqlite based on your choice. YYKVStorageTypeMixed = 2,&#125;; 如果是要存储大量的小数据，用YYKVStorageTypeSQLite性能会更好，如果是要存储大文件（比如图片缓存），使用YYKVStorageTypeFile来获取更好的性能，当然也可以使用YYKVStorageTypeMixed来自己决定每一个item的存储方式。 YYKVStorage实现文件依据它的思路分为两部分：sqlite和文件，它们的存储结构如下：12345678910111213141516171819202122232425/* File: /path/ /manifest.sqlite /manifest.sqlite-shm /manifest.sqlite-wal /data/ /e10adc3949ba59abbe56e057f20f883e /e10adc3949ba59abbe56e057f20f883e /trash/ /unused_file_or_folder SQL: create table if not exists manifest ( key text, filename text, size integer, inline_data blob, modification_time integer, last_access_time integer, extended_data blob, primary key(key) ); create index if not exists last_access_time_idx on manifest(last_access_time); */ File和SQL共用一张manifest表，如果是用SQL方式存储数据，则manifest表中的filename字段为空。这样设计的好处是，查询和修改item的信息只要查询一张表，效率上会高一点。 注：manifest.sqlite-shm和manifest.sqlite-wal是自sqlite 3.7后加入的，-wal文件的意思是write-ahead log，当一个数据库采用WAL模式，所有连接数据的操作都必须使用WAL，然后在数据库文件夹下生成后缀为-wal的文件来保存操作日志，-shm则说的是共享内存的问题，有兴趣可以看看下面这段。 2.2 Write-Ahead Log (WAL) Files A write-ahead log or WAL file is used in place of a rollback journal when SQLite is operating in WAL mode. As with the rollback journal, the purpose of the WAL file is to implement atomic commit and rollback. The WAL file is always located in the same directory as the database file and has the same name as the database file except with the 4 characters “-wal” appended. The WAL file is created when the first connection to the database is opened and is normally removed when the last connection to the database closes. However, if the last connection does not shutdown cleanly, the WAL file will remain in the filesystem and will be automatically cleaned up the next time the database is opened. 2.3 Shared-Memory Files When operating in WAL mode, all SQLite database connections associated with the same database file need to share some memory that is used as an index for the WAL file. In most implementations, this shared memory is implemented by calling mmap() on a file created for this sole purpose: the shared-memory file. The shared-memory file, if it exists, is located in the same directory as the database file and has the same name as the database file except with the 4 characters “-shm” appended. Shared memory files only exist while running in WAL mode. The shared-memory file contains no persistent content. The only purpose of the shared-memory file is to provide a block of shared memory for use by multiple processes all accessing the same database in WAL mode. If the VFS is able to provide an alternative method for accessing shared memory, then that alternative method might be used rather than the shared-memory file. For example, if PRAGMA locking_mode is set to EXCLUSIVE (meaning that only one process is able to access the database file) then the shared memory will be allocated from heap rather than out of the shared-memory file, and the shared-memory file will never be created. The shared-memory file has the same lifetime as its associated WAL file. The shared-memory file is created when the WAL file is created and is deleted when the WAL file is deleted. During WAL file recovery, the shared memory file is recreated from scratch based on the contents of the WAL file being recovered. sqlite3部分涉及到sqlite3预编译，它的预编译过程分为以下几步： 1.通过sqlite3_prepare_v2()创建sqlite3_stmt对象2.通过sqlite3bind*()绑定预编译字段的值3.通过sqlite2_step()执行SQL语句4.通过sqlite3_reset()重置预编译语句，重复步骤2多次5.通过sqlite3_finalize()销毁资源 sqlite3bind*有多种形式，分别对应不同的类型：123456789int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*)); int sqlite3_bind_double(sqlite3_stmt*, int, double);int sqlite3_bind_int(sqlite3_stmt*, int, int);int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);int sqlite3_bind_null(sqlite3_stmt*, int);int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*));int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n); YYDiskCacheYYDiskCache是线程安全的底层依赖于SQLite和File系统（类似于NSURLCache的磁盘缓存）来存储键值对的缓存YYDiskCache有以下的特性： 使用LRU算法来移除对象 能够被开销、数量和寿命来控制 当没有多余的磁盘空间时它能够自动回收对象 能够自动决定为每个对象决定存储类型（sqlite还是文件）以达到更好的性能 YYDiskCache结构如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@interface YYDiskCache : NSObject#pragma mark - Attribute/** The name of the cache. Default is nil. */@property (nullable, copy) NSString *name;/** The path of the cache (read-only). */@property (readonly) NSString *path;/** * 如果对象的数据大小超过这个值，那对象就会被当做文件存储起来，否则对象会以sqlite形式存储起来。 0意味着所有的对象会被以单独的文件存储起来，NSIntegerMax意味着所有的对象都会以sqlite形式存储。 */@property (readonly) NSUInteger inlineThreshold;/** * 如果这个block不为空，那么这个block会被用来取代NSKeyedArchiver序列化对象。 * 你可以使用这个block来支持那些没有实现&apos;NSCoding&apos;协议的对象 */@property (nullable, copy) NSData *(^customArchiveBlock)(id object);/** * 反序列化那些没有遵从&apos;NSCoding&apos;协议的对象 */@property (nullable, copy) id (^customUnarchiveBlock)(NSData *data);/** * 当一个对象需要以文件的形式存储起来时，这个block会被触发来以指定的key生成文件名。 如果block为空，缓存就使用md5加密的key来作为文件名 */@property (nullable, copy) NSString *(^customFileNameBlock)(NSString *key);#pragma mark - Limit/** * 缓存所拥有的对象的最大限制 默认值为NSIntegMax，这不是一个严格的限制——如果缓存超过了这个限制，一些对象会在后台队列中被回收 */@property NSUInteger countLimit;/** * 在缓存开始回收对象前它所能持有的所有代价 如果缓存超过这个限制，一些对象会在后台队列中被回收。 */@property NSUInteger costLimit;/** * 缓存中对象的生命周期 如果对象超过这个限制，它会在后台队列中被回收 */@property NSTimeInterval ageLimit;/** * 缓存保有的最小的空余磁盘空间大小 如果空余磁盘空间大小小于这个值，缓存会移除部分对象来释放磁盘空间。 */@property NSUInteger freeDiskSpaceLimit;/** * 缓存有一个内部的timer来检查缓存是否达到它的限制，如果达到限制，便开始回收对象。 */@property NSTimeInterval autoTrimInterval;/** Set `YES` to enable error logs for debug. */@property BOOL errorLogsEnabled; YYDiskCache实现部分采用dispatch_semaphore来控制同步的，而并没有采用性能非常好的OSSpinLock自旋锁，研究了一下原因。 OSSpinLock：得益于不进内核不挂起的方式，OSSpinLock有着优异的性能表现，然而在高并发执行(冲突概率大，竞争激烈)的时候，又或者代码片段比较耗时(比如涉及内核执行文件io、socket、thread等)，就容易引发CPU占有率暴涨的风险，因此更适用于一些简短低耗时的代码片段dispatch_semaphore：GCD用于控制多线程并发的信号量，允许通过wait/signal的信号事件控制并发执行的最大线程数，当最大线程数降级为1的时候则可当作同步锁使用，注意该信号量并不支持递归；性能虽不如OSSpinLock但性能表现也是出乎意料之外的好，也没有OSSpinLock的CPU占有率暴涨的问题，然而原本是用于GCD的多线程并发控制，也是信号量机制。 对于耗时较大又易冲突的读操作，可以使用dispatch_semaphore，对于性能要求苛刻，可以考虑使用OSSpinLock，但需要确保加锁片段的耗时足够小。由于YYDiskCache锁占用时间会比较长，使用OSSpinLock会造成CPU内存暴涨，相比之下，使用dispatch_semaphore性能上则会好很多。 YYMemoryCacheYYMemoryCache是一个高效的存储键值对的内存缓存。与NSDictionary相比，keys只被持有而并不进行拷贝, 其API和性能与NSCache接近，所有的方法都是线程安全的。它的特性如下： YYMemoryCache与NSCache在以下几个方面不同： 它使用LRU算法移除对象；NSCache的回收方法的策略是不确定的。 它可以被开销，数量和生命周期来控制；NSCache的限制是不确定的。 当收到内存警告和进入后台时，它可以自动回收对象。 YYMemoryCache使用pthread_mutex来控制同步。读写锁的在锁操作耗时上明显不占优势，读写锁的主要性能优势在于多线程高并发量的场景，这时候锁竞争可能会非常激烈，使用一般的锁这时候并发性能都会明显下降，读写锁对于所有读操作能够把同步放开，进而保持并发性能不受影响。由于内存缓存属于多线程高并发的使用场景，因此使用pthread_mutex会更稳定。 pthread_mutex：POSIX标准的unix多线程库(pthread)中使用的互斥量，支持递归，需要特别说明的是信号机制pthread_cond_wait()同步方式也是依赖于该互斥量，pthread_cond_wait()本身并不具备同步能力； YYMemoryCache的实现主要基于双链表，将链表的节点按照时间先后顺序逆序链接，若有节点被访问，则将该节点挪到表头，若插入新节点而缓存已满，则从链表表尾开始删除节点腾出存储空间。12345678910@interface _YYLinkedMapNode : NSObject &#123; @package __unsafe_unretained _YYLinkedMapNode *_prev; // retained by dic __unsafe_unretained _YYLinkedMapNode *_next; // retained by dic id _key; id _value; NSUInteger _cost; NSTimeInterval _time;&#125;@end YYMemoryCache创建一个YYMemoryCacheGetReleaseQueue来releaseCFMutableDictionaryRef对象，避免阻塞主线程。123static inline dispatch_queue_t YYMemoryCacheGetReleaseQueue() &#123; return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);&#125; YYMemoryCache的实现部分有段代码引起了我的注意：12345678910111213141516171819- (void)removeObjectForKey:(id)key &#123; if (!key) return; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); if (node) &#123; [_lru removeNode:node]; if (_lru-&gt;_releaseAsynchronously) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [node class]; //hold and release in queue &#125;); &#125; else if (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [node class]; //hold and release in queue &#125;); &#125; &#125; pthread_mutex_unlock(&amp;_lock);&#125; 这段代码实现的很巧妙，removeObjectForKey:方法执行完之后，node指向的对象的引用计数为0需要被释放，但是由于在dispatch_async方法中的block中调用了[node class];，使得blcok持有node，其指向的对象也就不会释放，而此时只有dispatch_async的block持有node，也就自然node释放的过程发生在dispatch_async指定的线程当中。 YYCacheYYCache是线程安全的键值对缓存。它使用YYMemoryCache将对象存储在速度快但空间小的内存缓存中，使用YYDiskCache将对象持久化存储在速度慢但空间大的磁盘缓存中。其类结构也很简单：12345678@interface YYCache : NSObject/** The name of the cache, readonly. */@property (copy, readonly) NSString *name;/** The underlying memory cache. see `YYMemoryCache` for more information.*/@property (strong, readonly) YYMemoryCache *memoryCache;/** The underlying disk cache. see `YYDiskCache` for more information.*/@property (strong, readonly) YYDiskCache *diskCache;@end YYCache没有太复杂的实现细节，主要就是调用YYMemoryCache和YYDiskCache相关方法存储、查找、修改、删除对象。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"runtime对containsString方法的小改进","slug":"runtime对containsString方法的小改进","date":"2016-02-20T15:23:28.000Z","updated":"2016-09-06T15:27:00.000Z","comments":true,"path":"2016/02/20/runtime对containsString方法的小改进/","link":"","permalink":"http://yoursite.com/2016/02/20/runtime对containsString方法的小改进/","excerpt":"最近做项目过程中版本适配到iOS 7上出现了一点问题，定位分析了一下发现原来是NSstring的containsString:方法在从中作梗。看了一下文档发现原来containsString:是从iOS 8才加入的，iOS 7 SDK并没有该方法。这个问题解决起来也挺简单的，在iOS 7下可以用如下代码代替containsString:方法： 1BOOL isContained = [aString rangeOfString:bString].location != NSNotFound 不过，我觉得要在每一个需要调用containsString:方法写一遍有点麻烦，把适配的代码抽离出来写入一个方法倒是可以，但我还是觉得有点麻烦，毕竟懒癌患者。于是，我想到了用runtime运行时机制动态添加containsString:方法就可以一劳永逸了。实现的原理也很简单，在iOS 7下判断NSString中是否存在containsString:实例方法，若不存在，则动态添加该方法。这样就不用再需要调用containsString:实例方法去判断了。原理很简单，代码也很简单，还是很符合我这个懒癌患者的口味的嘛。","text":"最近做项目过程中版本适配到iOS 7上出现了一点问题，定位分析了一下发现原来是NSstring的containsString:方法在从中作梗。看了一下文档发现原来containsString:是从iOS 8才加入的，iOS 7 SDK并没有该方法。这个问题解决起来也挺简单的，在iOS 7下可以用如下代码代替containsString:方法： 1BOOL isContained = [aString rangeOfString:bString].location != NSNotFound 不过，我觉得要在每一个需要调用containsString:方法写一遍有点麻烦，把适配的代码抽离出来写入一个方法倒是可以，但我还是觉得有点麻烦，毕竟懒癌患者。于是，我想到了用runtime运行时机制动态添加containsString:方法就可以一劳永逸了。实现的原理也很简单，在iOS 7下判断NSString中是否存在containsString:实例方法，若不存在，则动态添加该方法。这样就不用再需要调用containsString:实例方法去判断了。原理很简单，代码也很简单，还是很符合我这个懒癌患者的口味的嘛。12345678910111213// NSString+containsStringCategory.h#import &lt;Foundation/Foundation.h&gt;#if __IPHONE_OS_VERSION_MIN_REQUIRED &lt; 80000@interface NSString (containsStringCategory)- (BOOL)containsString:(NSString *)str;@end#endif 1234567891011121314151617181920212223242526272829// NSString+containsStringCategory.m#import &quot;NSString+containsStringCategory.h&quot;#import &lt;objc/runtime.h&gt;#if __IPHONE_OS_VERSION_MIN_REQUIRED &lt; 80000@implementation NSString (containsStringCategory)+ (void)load&#123; @autoreleasepool &#123; [self zs_modernizeSelector:@selector(containsString:) withSelector:@selector(zs_containsString:)]; &#125;&#125;+ (void)zs_modernizeSelector:(SEL)originSelector withSelector:(SEL)newSelector&#123; if (![NSString instancesRespondToSelector:originSelector]) &#123; Method newMethod = class_getInstanceMethod(self, newSelector); class_addMethod(self, originSelector, method_getImplementation(newMethod), method_getTypeEncoding(newMethod)); &#125;&#125;- (BOOL)zs_containsString:(NSString *)str&#123; return [self rangeOfString:str].location != NSNotFound;&#125;@end#endif","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"UIImage加载图片方式的研究","slug":"UIImage加载图片方式的研究","date":"2016-01-20T11:56:39.000Z","updated":"2016-08-30T13:19:34.000Z","comments":true,"path":"2016/01/20/UIImage加载图片方式的研究/","link":"","permalink":"http://yoursite.com/2016/01/20/UIImage加载图片方式的研究/","excerpt":"常用的UIImage加载图片的方式有以下几种： [UIImage imageNamed:name] [UIImage imageWithContentsOfFile:name] [UIImage imageWithData:data] [UIImage imageWithCGImage:imageRef] [UIImage imageWithCIImage:obj] 以上方法中imageNamed:和imageWitData:应用程序会对其自动缓存，不过，它们缓存的实现方式并不相同，后面会有详细说明。除去这两个方法以外剩下的三个方法默认情况下是不会产生缓存的，这三个方法的主要区别在于它们的数据源：imageWithContentsOfFile:从指定文件中创建对象，imageWithCGImage:以CGImageRef来创建对象，imageWithCIImage:以CIImage对象来创建对象。最后两种方法平时用的相对会少一些，简要解释一下CGImage与CIImage的区别：CGImageRef只能代表位图，如果你需要与bitmap数据打交道，无疑CGImage是非常合适的选择。CGImageRef以CG开头就不难想到CGImageRef的相关操作都需要在Core Graphics中进行，比如混合、遮罩等等。CIImage以CI开头，即Core Image，不难理解CIImage是底层的数据对象，它通常包含了与它相关的图像数据，而不是一个图像。默认情况下，CIImage对象是不会被绘图系统渲染的，除非是得到明确的指令。这种机制（“lazy evaluation”）允许核心绘图系统尽可能高效地运行。CIImage通常被运用在GPU优化图像滤镜算法当中。","text":"常用的UIImage加载图片的方式有以下几种： [UIImage imageNamed:name] [UIImage imageWithContentsOfFile:name] [UIImage imageWithData:data] [UIImage imageWithCGImage:imageRef] [UIImage imageWithCIImage:obj] 以上方法中imageNamed:和imageWitData:应用程序会对其自动缓存，不过，它们缓存的实现方式并不相同，后面会有详细说明。除去这两个方法以外剩下的三个方法默认情况下是不会产生缓存的，这三个方法的主要区别在于它们的数据源：imageWithContentsOfFile:从指定文件中创建对象，imageWithCGImage:以CGImageRef来创建对象，imageWithCIImage:以CIImage对象来创建对象。最后两种方法平时用的相对会少一些，简要解释一下CGImage与CIImage的区别：CGImageRef只能代表位图，如果你需要与bitmap数据打交道，无疑CGImage是非常合适的选择。CGImageRef以CG开头就不难想到CGImageRef的相关操作都需要在Core Graphics中进行，比如混合、遮罩等等。CIImage以CI开头，即Core Image，不难理解CIImage是底层的数据对象，它通常包含了与它相关的图像数据，而不是一个图像。默认情况下，CIImage对象是不会被绘图系统渲染的，除非是得到明确的指令。这种机制（“lazy evaluation”）允许核心绘图系统尽可能高效地运行。CIImage通常被运用在GPU优化图像滤镜算法当中。 UIImage缓存原理1.[UIImage imageNamed:name]我通过查看imageNamed方法的调用栈以及查阅苹果相关文档后对UIImage的缓存实现有了清晰的认识。当调用imageNamed方法时，该方法会去内存缓存里去查找与参数一致的image对象并且返回最合适大小的image对象，如果没有找到，该方法则会去本地磁盘中查找然后加载图片并返回image对象，同时将image对象缓存到系统缓存中，以便下次重复使用。更底层一点的解释，当返回image对象时，并未对image的图片数据进行解码。它的解码过程发生在UIImage对象第一次显示到屏幕上的时候，而image对象的缓存也发生在这时候。当解码完成image显示在屏幕上后，应用程序会将image的解码结果保存到缓存中。通常缓存会在收到内存警告时才会被清空。 2.[UIImage imageWithData:data]在查看imageWithData方法的调用栈时发现了有意思的东西。通过二进制数据创建image对象时，实际上在底层调用的是ImageIO/ImageIO.h的CGImageSourceCreateWithData()方法。该方法的第二个参数可以传入key为kCGImageSourceShouldCache的键值对，它的值是CFBooleanRef类型的，默认情况下，在64位机器上它的值为kCFBooleanTrue，而在32位机器上它的值为kCFBooleanFalse。也就是说在64位机器上是会缓存的，而在32位机器上则是不会缓存的。与imageNamed方法类似，图片会在第一次显示到屏幕上时才会进行解码，随后再被缓存到CGImage里面。依据是CGImageSourceCreateWithData()方法第二个参数可以传入key为kCGImageSourceShouldCacheImmediately的键值对，默认情况下它的值是kCFBooleanFalse。 UIImage不缓存 [UIImage imageWithContentsOfFile:name]与前面两个方法略有不同，该方法是同步的（synchronous）。当在主线程（UI）中调用该方法时，会阻塞主线程并从磁盘中加载图片数据，若磁盘数据较大会造成卡顿或者延迟。通常的解决方法是另开一个线程异步完成磁盘加载图片数据的任务，然后在主线程中刷新UI。下面代码给出了一个例子： 123456789dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123; UIImage *image = [UIImage imageWithContentsOfFile:imagePath]; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.button setBackgroundImage:image forState:UIControlStateNormal]; &#125;);&#125;); 当图片显示在屏幕上时，系统并不会对其进行缓存。当图片数据被加载到内存中，它会被标记为可清除（purgeable）。如果数据被清除了且需要再次加载，image对象会再次从指定的文件路径获取数据并加载进内存中。根据它的实现原理，通常该方法的使用场景是图片不需要重复展示，或者图片的数据较大会造成内存警告。当然，这并不是说imageWithContentsOfFile:一定比imageNamed:方法高效，imageWithContentsOfFile:方法的问题在于它会将图片文件全尺寸展示在屏幕上即使是512*512的图片都要占到1M多的内存，加载会影响程序的性能，造成不好的用户体验。针对图片尺寸太大带来的性能问题，比较好的解决方案是用CGImageSource的有关方法，将图片的尺寸缩减到适合的尺寸，减小数据大小。123456789101112131415161718192021#import &lt;ImageIO/ImageIO.h&gt;NSURL *imageFileURL = [NSURL fileURLWithPath:...];CGImageSourceRef imageSource = CGImageSourceCreateWithURL((CFURLRef)imageFileURL, NULL);if (imageSource == NULL) &#123; // Error loading image ... return;&#125;NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithBool:NO], (NSString *)kCGImageSourceShouldCache, nil];CFDictionaryRef imageProperties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, (CFDictionaryRef)options);if (imageProperties) &#123; NSNumber *width = (NSNumber *)CFDictionaryGetValue(imageProperties, kCGImagePropertyPixelWidth); NSNumber *height = (NSNumber *)CFDictionaryGetValue(imageProperties, kCGImagePropertyPixelHeight); NSLog(@&quot;Image dimensions: %@ x %@ px&quot;, width, height); CFRelease(imageProperties);&#125;CFRelease(imageSource);","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"ApplePay线上支付教程","slug":"ApplePay线上支付教程","date":"2016-01-14T12:33:39.000Z","updated":"2016-08-30T13:19:27.000Z","comments":true,"path":"2016/01/14/ApplePay线上支付教程/","link":"","permalink":"http://yoursite.com/2016/01/14/ApplePay线上支付教程/","excerpt":"第一部分 准备阶段1）硬件要求：iPhone6及更新的设备，还有iPad air2和iPad mini3之后的平板，以及apple watch。具体型号（截止2016年2月）：iPhone 6，iPhone 6 Plus，iPhone 6s， iPhone 6s Plus；iPad Air 2，iPad mini 3，iPad mini 4，iPad Pro；还有Apple Watch。 2）系统要求：iPhone或iPad至少要升到iOS 9.2版，手表至少watch OS 2.1。 3）配置支付环境1.进入苹果开发者中心，注册App ID。App ID必须是explicit类型，否则无法使用ApplePay服务。","text":"第一部分 准备阶段1）硬件要求：iPhone6及更新的设备，还有iPad air2和iPad mini3之后的平板，以及apple watch。具体型号（截止2016年2月）：iPhone 6，iPhone 6 Plus，iPhone 6s， iPhone 6s Plus；iPad Air 2，iPad mini 3，iPad mini 4，iPad Pro；还有Apple Watch。 2）系统要求：iPhone或iPad至少要升到iOS 9.2版，手表至少watch OS 2.1。 3）配置支付环境1.进入苹果开发者中心，注册App ID。App ID必须是explicit类型，否则无法使用ApplePay服务。 2.勾选Apple Pay并点击continue，然后点击“submit”提交。 3.在App IDs中找到刚刚注册成功的App ID，点击edit，对Apple Pay进行配置。 4.创建MerchantID。 5.配置Apple Pay服务，勾选Merchant ID。 6.App ID的apple pay选项变成enable表示配置成功。 7.创建Xcode项目，填入刚注册的BundleID。 8.在项目的target-&gt;Capabilities中，打开Apple Pay，并勾选Merchant ID。 第二部分 代码实现项目地址：https://github.com/ZakariyyaSv/ApplePayDemo 一、判断支付环境1.导入Passkit框架，加载view。1#import &lt;PassKit/PassKit.h&gt; 2.判断当前设备是否支持Apple Pay以及wallet中是否有符合所支持网络的银行卡。1234567891011121314151617181920// 1.判断当前设备是否支持ApplePayif ([PKPaymentAuthorizationViewController canMakePayments]) &#123; // 2.判断是否添加了银行卡 if ([PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:@[PKPaymentNetworkChinaUnionPay]]) &#123; // 3.1添加支付按钮，点击跳转去支付 PKPaymentButton *buyBtn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeBuy style:PKPaymentButtonStyleBlack]; [buyBtn addTarget:self action:@selector(buyOnClick) forControlEvents:UIControlEventTouchUpInside]; [self.payView addSubview:buyBtn]; &#125; else &#123; // 3.2添加设置按钮，点击跳转去wallet绑定银行卡 PKPaymentButton *setupBtn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeSetUp style:PKPaymentButtonStyleWhiteOutline]; [setupBtn addTarget:self action:@selector(jumpToWallet) forControlEvents:UIControlEventTouchUpInside]; [self.payView addSubview:setupBtn]; &#125;&#125;else &#123; NSLog(@&quot;The device cannot support ApplePay!&quot;);&#125; 运行效果如下图所示： 3.若wallet中没有绑定所支持网络的银行卡，则点击按钮跳转到wallet中去绑定银行卡。1234- (void)jumpToWallet&#123; PKPassLibrary *walletLibrary = [[PKPassLibrary alloc] init]; [walletLibrary openPaymentSetup];&#125; 4.若该设备支持Apple Pay并且有绑定所支持网络的银行卡则发起支付请求。12345678910111213141516171819202122232425- (void)buyOnClick&#123; NSLog(@&quot;start to pay!&quot;); // 创建支付请求，配置请求信息。 PKPaymentRequest *payRequest = [[PKPaymentRequest alloc] init]; // 国家代码 payRequest.countryCode = @&quot;CN&quot;; // 货币代码 payRequest.currencyCode = @&quot;CNY&quot;; // 商家ID payRequest.merchantIdentifier = @&quot;merchant.com.zakariyya.fabrunMerchant&quot;; // 商家的处理方式 payRequest.merchantCapabilities = PKMerchantCapability3DS; // 商家支持的网络 payRequest.supportedNetworks = @[PKPaymentNetworkChinaUnionPay]; // 配置支付订单的详情 PKPaymentSummaryItem *cameraItem = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;单反相机&quot; amount:[NSDecimalNumber decimalNumberWithString:@&quot;5999.0&quot;] type:PKPaymentSummaryItemTypeFinal]; PKPaymentSummaryItem *totalItem = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;佳能&quot; amount:[NSDecimalNumber decimalNumberWithString:@&quot;5999.0&quot;] type:PKPaymentSummaryItemTypeFinal]; payRequest.paymentSummaryItems = @[cameraItem,totalItem]; // 跳转并验证支付权限 PKPaymentAuthorizationViewController *authViewController = [[PKPaymentAuthorizationViewController alloc] initWithPaymentRequest:payRequest]; authViewController.delegate = self; [self presentViewController:authViewController animated:YES completion:nil];&#125; 支付请求配置包括国家代码、货币代码、商家ID、商家的处理方式、商家支持的网络、订单的详情，这几个要素缺一不可。其中，merchantCapabilities是一个枚举值：123456typedef NS_OPTIONS(NSUInteger, PKMerchantCapability) &#123; PKMerchantCapability3DS = 1UL &lt;&lt; 0, // Merchant supports 3DS PKMerchantCapabilityEMV = 1UL &lt;&lt; 1, // Merchant supports EMV PKMerchantCapabilityCredit NS_ENUM_AVAILABLE_IOS(9_0) = 1UL &lt;&lt; 2, // Merchant supports credit PKMerchantCapabilityDebit NS_ENUM_AVAILABLE_IOS(9_0) = 1UL &lt;&lt; 3 // Merchant supports debit&#125; NS_ENUM_AVAILABLE(NA, 8_0); 这些枚举值当中PKMerchantCapability3DS是必选项，其他的则是可选项。 supportedNetworks是一个包含常量字符串的数组：1234567extern NSString * const PKPaymentNetworkAmex NS_AVAILABLE(NA, 8_0);extern NSString * const PKPaymentNetworkChinaUnionPay NS_AVAILABLE(NA, 9_2);extern NSString * const PKPaymentNetworkDiscover NS_AVAILABLE(NA, 9_0);extern NSString * const PKPaymentNetworkInterac NS_AVAILABLE(NA, 9_2);extern NSString * const PKPaymentNetworkMasterCard NS_AVAILABLE(NA, 8_0);extern NSString * const PKPaymentNetworkPrivateLabel NS_AVAILABLE(NA, 9_0);extern NSString * const PKPaymentNetworkVisa NS_AVAILABLE(NA, 8_0); 国内一般我们用到的会是中国银联，即PKPaymentNetworkChinaUnionPay，注意：iOS 9.2以后才开始支持银联支付。 5.监听用户授权状态1234567891011121314151617181920#pragma mark - PKPaymentAuthorizationViewControllerDelegate// 用户授权成功后调用此方法- (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller didAuthorizePayment:(PKPayment *)payment completion:(void (^)(PKPaymentAuthorizationStatus))completion&#123; // 一般在此处，拿到支付信息，发送给服务端处理，处理完毕后，服务器会返回一个状态来告诉客户端是否支付成功，然后由客户端进行处理。 BOOL isSuccess = YES; if (isSuccess) &#123; completion(PKPaymentAuthorizationStatusSuccess); &#125; else &#123; completion(PKPaymentAuthorizationStatusFailure); &#125;&#125;// 用户授权成功或者用户取消授权操作时调用该方法- (void)paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller&#123; NSLog(@&quot;Authorization did finished!&quot;); [self dismissViewControllerAnimated:YES completion:nil];&#125; 附：","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]}]}