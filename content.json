{"meta":{"title":"zakariyyaSv","subtitle":null,"description":"Just Forcus","author":"zakariyyaSv","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2016-08-28T14:48:20.000Z","updated":"2016-08-28T14:51:25.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"拆解ARC下的self","slug":"拆解ARC下的self","date":"2016-08-24T13:23:28.000Z","updated":"2016-08-28T14:45:23.000Z","comments":true,"path":"2016/08/24/拆解ARC下的self/","link":"","permalink":"http://yoursite.com/2016/08/24/拆解ARC下的self/","excerpt":"最近在研究AFNetworking源码的过程中碰到了很多处地方用到了weakSelf和strongSelf。依据自己之前的理解，正常情况下使用weakSelf是为了避免发生循环引用，而使用strongSelf是为了避免方法还没有执行完成self已经被释放从而导致崩溃。不过为何在方法执行完成之前无法确保self不被释放却不是很明白，于是乎，自己花了些时间研究了一下。 ###self的本质### self是类的隐藏参数，在类方法中self指向当前调用方法的类，在实例方法中指向当前调用方法的类的init方法族生成的实例。更准确来说，在类方法中self是const Class self，在实例方法中self是Person const* self（以Person类举例）。事实确实如此么？来验证一下。","text":"最近在研究AFNetworking源码的过程中碰到了很多处地方用到了weakSelf和strongSelf。依据自己之前的理解，正常情况下使用weakSelf是为了避免发生循环引用，而使用strongSelf是为了避免方法还没有执行完成self已经被释放从而导致崩溃。不过为何在方法执行完成之前无法确保self不被释放却不是很明白，于是乎，自己花了些时间研究了一下。 ###self的本质### self是类的隐藏参数，在类方法中self指向当前调用方法的类，在实例方法中指向当前调用方法的类的init方法族生成的实例。更准确来说，在类方法中self是const Class self，在实例方法中self是Person const* self（以Person类举例）。事实确实如此么？来验证一下。 12345678910111213141516#import &quot;Person.h&quot;@implementation Person- (void)eat&#123;&#125;+ (void)classEat&#123;&#125;- (void)drink:(NSString *)sth&#123; [self eat];&#125;@end 将Person.m用clang命令进行重写，得到的代码如下： 12345678910static void _I_Person_eat(Person * self, SEL _cmd) &#123; id obj = ((Person *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;Person&quot;))&#125;, sel_registerName(&quot;init&quot;));&#125;static void _C_Person_classEat(Class self, SEL _cmd) &#123;&#125;static void _I_Person_drink_(Person * self, SEL _cmd, NSString *sth) &#123; ((void (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(&quot;eat&quot;));&#125; 从重写后的代码中可以看出结论是正确的，但还是没有找到self在方法执行过程中可能被释放的原因。我又查阅了Clang的官方文档,找到了其中关于self的说明： The self parameter variable of an Objective-C method is never actually retained by the implementation. It is undefined behavior, or at least dangerous, to cause an object to be deallocated during a message send to that object. To make this safe, for Objective-C instance methods self is implicitly const unless the method is in the init family. Further, self is always implicitly const within a class method. 翻译过来就是在OC方法中作为参数的self不会被方法的实现持有，当给self指向的对象发送消息时确实可能会发生错误。为了确保安全，除非是在init及类init的方法中，否则在OC的实例方法和类方法中self始终是指针常量无法被retain。根据我的理解整理如下： 在ARC中，self的修饰符是unsafe_unretained，而不是strong。unsafe_unretained与weak类似，均是对对象的弱引用，区别在于当unsafe_unretained的指针指向的对象被释放后，指针仍会指向被释放对象的内存地址，变成野指针导致crash，而当weak的指针指向的对象被释放后，指针指向的对象会被置为nil。正是由于unsafe_unretained修饰符的作用，因此会导致在方法执行的过程若self被释放则会引起crash。 OC方法不会对self自动retain（除了init方法族以外），self在方法运行过程中的生命周期需要由程序员自己手动实现来保证。通常的做法也就是在方法中添加一个局部变量strongSelf来对self指向的对象进行强引用来保证在方法执行完之前self都不会被释放。 对self采用__unsafe_unretained修饰符，主要是为了性能方面的考虑。通常调用一个方法被runtime改写成objc_msgSend()后，传入的第一个参数都是self，从上面clang重写的代码中也可以看出。若是在方法调用中对self进行retain和release，确实可以保证方法执行过程中self不会被释放，但是，会对性能产生很大影响。并且在大多数方法调用过程中，self是不会被释放的，因此，不对self进行reatain和release操作所带来的性能提升是值得的。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"ApplePay线上支付教程","slug":"ApplePay线上支付教程","date":"2016-01-14T12:33:39.000Z","updated":"2016-08-29T13:24:45.000Z","comments":true,"path":"2016/01/14/ApplePay线上支付教程/","link":"","permalink":"http://yoursite.com/2016/01/14/ApplePay线上支付教程/","excerpt":"##第一部分 准备阶段 1）硬件要求：iPhone6及更新的设备，还有iPad air2和iPad mini3之后的平板，以及apple watch。具体型号（截止2016年2月）：iPhone 6，iPhone 6 Plus，iPhone 6s， iPhone 6s Plus；iPad Air 2，iPad mini 3，iPad mini 4，iPad Pro；还有Apple Watch。 2）系统要求：iPhone或iPad至少要升到iOS 9.2版，手表至少watch OS 2.1。 3）配置支付环境1.进入苹果开发者中心，注册App ID。App ID必须是explicit类型，否则无法使用ApplePay服务。","text":"##第一部分 准备阶段 1）硬件要求：iPhone6及更新的设备，还有iPad air2和iPad mini3之后的平板，以及apple watch。具体型号（截止2016年2月）：iPhone 6，iPhone 6 Plus，iPhone 6s， iPhone 6s Plus；iPad Air 2，iPad mini 3，iPad mini 4，iPad Pro；还有Apple Watch。 2）系统要求：iPhone或iPad至少要升到iOS 9.2版，手表至少watch OS 2.1。 3）配置支付环境1.进入苹果开发者中心，注册App ID。App ID必须是explicit类型，否则无法使用ApplePay服务。 2.勾选Apple Pay并点击continue，然后点击“submit”提交。 3.在App IDs中找到刚刚注册成功的App ID，点击edit，对Apple Pay进行配置。 4.创建MerchantID。 5.配置Apple Pay服务，勾选Merchant ID。 6.App ID的apple pay选项变成enable表示配置成功。 7.创建Xcode项目，填入刚注册的BundleID。 8.在项目的target-&gt;Capabilities中，打开Apple Pay，并勾选Merchant ID。 ##第二部分 代码实现 项目地址：https://github.com/ZakariyyaSv/ApplePayDemo ####一、判断支付环境1.导入Passkit框架，加载view。1#import &lt;PassKit/PassKit.h&gt; 2.判断当前设备是否支持Apple Pay以及wallet中是否有符合所支持网络的银行卡。1234567891011121314151617181920// 1.判断当前设备是否支持ApplePayif ([PKPaymentAuthorizationViewController canMakePayments]) &#123; // 2.判断是否添加了银行卡 if ([PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:@[PKPaymentNetworkChinaUnionPay]]) &#123; // 3.1添加支付按钮，点击跳转去支付 PKPaymentButton *buyBtn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeBuy style:PKPaymentButtonStyleBlack]; [buyBtn addTarget:self action:@selector(buyOnClick) forControlEvents:UIControlEventTouchUpInside]; [self.payView addSubview:buyBtn]; &#125; else &#123; // 3.2添加设置按钮，点击跳转去wallet绑定银行卡 PKPaymentButton *setupBtn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeSetUp style:PKPaymentButtonStyleWhiteOutline]; [setupBtn addTarget:self action:@selector(jumpToWallet) forControlEvents:UIControlEventTouchUpInside]; [self.payView addSubview:setupBtn]; &#125;&#125;else &#123; NSLog(@&quot;The device cannot support ApplePay!&quot;);&#125; 运行效果如下图所示： 3.若wallet中没有绑定所支持网络的银行卡，则点击按钮跳转到wallet中去绑定银行卡。1234- (void)jumpToWallet&#123; PKPassLibrary *walletLibrary = [[PKPassLibrary alloc] init]; [walletLibrary openPaymentSetup];&#125; 4.若该设备支持Apple Pay并且有绑定所支持网络的银行卡则发起支付请求。12345678910111213141516171819202122232425- (void)buyOnClick&#123; NSLog(@&quot;start to pay!&quot;); // 创建支付请求，配置请求信息。 PKPaymentRequest *payRequest = [[PKPaymentRequest alloc] init]; // 国家代码 payRequest.countryCode = @&quot;CN&quot;; // 货币代码 payRequest.currencyCode = @&quot;CNY&quot;; // 商家ID payRequest.merchantIdentifier = @&quot;merchant.com.zakariyya.fabrunMerchant&quot;; // 商家的处理方式 payRequest.merchantCapabilities = PKMerchantCapability3DS; // 商家支持的网络 payRequest.supportedNetworks = @[PKPaymentNetworkChinaUnionPay]; // 配置支付订单的详情 PKPaymentSummaryItem *cameraItem = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;单反相机&quot; amount:[NSDecimalNumber decimalNumberWithString:@&quot;5999.0&quot;] type:PKPaymentSummaryItemTypeFinal]; PKPaymentSummaryItem *totalItem = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;佳能&quot; amount:[NSDecimalNumber decimalNumberWithString:@&quot;5999.0&quot;] type:PKPaymentSummaryItemTypeFinal]; payRequest.paymentSummaryItems = @[cameraItem,totalItem]; // 跳转并验证支付权限 PKPaymentAuthorizationViewController *authViewController = [[PKPaymentAuthorizationViewController alloc] initWithPaymentRequest:payRequest]; authViewController.delegate = self; [self presentViewController:authViewController animated:YES completion:nil];&#125; 支付请求配置包括国家代码、货币代码、商家ID、商家的处理方式、商家支持的网络、订单的详情，这几个要素缺一不可。其中，merchantCapabilities是一个枚举值：123456typedef NS_OPTIONS(NSUInteger, PKMerchantCapability) &#123; PKMerchantCapability3DS = 1UL &lt;&lt; 0, // Merchant supports 3DS PKMerchantCapabilityEMV = 1UL &lt;&lt; 1, // Merchant supports EMV PKMerchantCapabilityCredit NS_ENUM_AVAILABLE_IOS(9_0) = 1UL &lt;&lt; 2, // Merchant supports credit PKMerchantCapabilityDebit NS_ENUM_AVAILABLE_IOS(9_0) = 1UL &lt;&lt; 3 // Merchant supports debit&#125; NS_ENUM_AVAILABLE(NA, 8_0); 这些枚举值当中PKMerchantCapability3DS是必选项，其他的则是可选项。 supportedNetworks是一个包含常量字符串的数组：1234567extern NSString * const PKPaymentNetworkAmex NS_AVAILABLE(NA, 8_0);extern NSString * const PKPaymentNetworkChinaUnionPay NS_AVAILABLE(NA, 9_2);extern NSString * const PKPaymentNetworkDiscover NS_AVAILABLE(NA, 9_0);extern NSString * const PKPaymentNetworkInterac NS_AVAILABLE(NA, 9_2);extern NSString * const PKPaymentNetworkMasterCard NS_AVAILABLE(NA, 8_0);extern NSString * const PKPaymentNetworkPrivateLabel NS_AVAILABLE(NA, 9_0);extern NSString * const PKPaymentNetworkVisa NS_AVAILABLE(NA, 8_0); 国内一般我们用到的会是中国银联，即PKPaymentNetworkChinaUnionPay，注意：iOS 9.2以后才开始支持银联支付。 5.监听用户授权状态1234567891011121314151617181920#pragma mark - PKPaymentAuthorizationViewControllerDelegate// 用户授权成功后调用此方法- (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller didAuthorizePayment:(PKPayment *)payment completion:(void (^)(PKPaymentAuthorizationStatus))completion&#123; // 一般在此处，拿到支付信息，发送给服务端处理，处理完毕后，服务器会返回一个状态来告诉客户端是否支付成功，然后由客户端进行处理。 BOOL isSuccess = YES; if (isSuccess) &#123; completion(PKPaymentAuthorizationStatusSuccess); &#125; else &#123; completion(PKPaymentAuthorizationStatusFailure); &#125;&#125;// 用户授权成功或者用户取消授权操作时调用该方法- (void)paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller&#123; NSLog(@&quot;Authorization did finished!&quot;); [self dismissViewControllerAnimated:YES completion:nil];&#125; ##附：","categories":[],"tags":[],"keywords":[]}]}