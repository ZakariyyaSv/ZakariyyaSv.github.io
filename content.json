{"meta":{"title":"zakariyyaSv's Blog","subtitle":null,"description":"Just Forcus","author":"zakariyyaSv","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2016-08-30T13:07:24.000Z","updated":"2016-08-30T13:08:58.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"iOS","date":"2016-08-30T12:56:19.000Z","updated":"2016-08-30T12:56:19.000Z","comments":true,"path":"iOS/index.html","permalink":"http://yoursite.com/iOS/index.html","excerpt":"","text":""}],"posts":[{"title":"拆解ARC下的self","slug":"拆解ARC下的self","date":"2016-08-24T13:23:28.000Z","updated":"2016-08-30T13:18:49.000Z","comments":true,"path":"2016/08/24/拆解ARC下的self/","link":"","permalink":"http://yoursite.com/2016/08/24/拆解ARC下的self/","excerpt":"最近在研究AFNetworking源码的过程中碰到了很多处地方用到了weakSelf和strongSelf。依据自己之前的理解，正常情况下使用weakSelf是为了避免发生循环引用，而使用strongSelf是为了避免方法还没有执行完成self已经被释放从而导致崩溃。不过为何在方法执行完成之前无法确保self不被释放却不是很明白，于是乎，自己花了些时间研究了一下。 self的本质self是类的隐藏参数，在类方法中self指向当前调用方法的类，在实例方法中指向当前调用方法的类的init方法族生成的实例。更准确来说，在类方法中self是const Class self，在实例方法中self是Person const* self（以Person类举例）。事实确实如此么？来验证一下。","text":"最近在研究AFNetworking源码的过程中碰到了很多处地方用到了weakSelf和strongSelf。依据自己之前的理解，正常情况下使用weakSelf是为了避免发生循环引用，而使用strongSelf是为了避免方法还没有执行完成self已经被释放从而导致崩溃。不过为何在方法执行完成之前无法确保self不被释放却不是很明白，于是乎，自己花了些时间研究了一下。 self的本质self是类的隐藏参数，在类方法中self指向当前调用方法的类，在实例方法中指向当前调用方法的类的init方法族生成的实例。更准确来说，在类方法中self是const Class self，在实例方法中self是Person const* self（以Person类举例）。事实确实如此么？来验证一下。 12345678910111213141516#import &quot;Person.h&quot;@implementation Person- (void)eat&#123;&#125;+ (void)classEat&#123;&#125;- (void)drink:(NSString *)sth&#123; [self eat];&#125;@end 将Person.m用clang命令进行重写，得到的代码如下： 12345678910static void _I_Person_eat(Person * self, SEL _cmd) &#123; id obj = ((Person *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;Person&quot;))&#125;, sel_registerName(&quot;init&quot;));&#125;static void _C_Person_classEat(Class self, SEL _cmd) &#123;&#125;static void _I_Person_drink_(Person * self, SEL _cmd, NSString *sth) &#123; ((void (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(&quot;eat&quot;));&#125; 从重写后的代码中可以看出结论是正确的，但还是没有找到self在方法执行过程中可能被释放的原因。我又查阅了Clang的官方文档,找到了其中关于self的说明： The self parameter variable of an Objective-C method is never actually retained by the implementation. It is undefined behavior, or at least dangerous, to cause an object to be deallocated during a message send to that object. To make this safe, for Objective-C instance methods self is implicitly const unless the method is in the init family. Further, self is always implicitly const within a class method. 翻译过来就是在OC方法中作为参数的self不会被方法的实现持有，当给self指向的对象发送消息时确实可能会发生错误。为了确保安全，除非是在init及类init的方法中，否则在OC的实例方法和类方法中self始终是指针常量无法被retain。根据我的理解整理如下： 在ARC中，self的修饰符是unsafe_unretained，而不是strong。unsafe_unretained与weak类似，均是对对象的弱引用，区别在于当unsafe_unretained的指针指向的对象被释放后，指针仍会指向被释放对象的内存地址，变成野指针导致crash，而当weak的指针指向的对象被释放后，指针指向的对象会被置为nil。正是由于unsafe_unretained修饰符的作用，因此会导致在方法执行的过程若self被释放则会引起crash。 OC方法不会对self自动retain（除了init方法族以外），self在方法运行过程中的生命周期需要由程序员自己手动实现来保证。通常的做法也就是在方法中添加一个局部变量strongSelf来对self指向的对象进行强引用来保证在方法执行完之前self都不会被释放。 对self采用__unsafe_unretained修饰符，主要是为了性能方面的考虑。通常调用一个方法被runtime改写成objc_msgSend()后，传入的第一个参数都是self，从上面clang重写的代码中也可以看出。若是在方法调用中对self进行retain和release，确实可以保证方法执行过程中self不会被释放，但是，会对性能产生很大影响。并且在大多数方法调用过程中，self是不会被释放的，因此，不对self进行reatain和release操作所带来的性能提升是值得的。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"Mac workflow小记","slug":"Mac workflow小记","date":"2016-03-12T12:11:39.000Z","updated":"2016-08-31T12:36:47.000Z","comments":true,"path":"2016/03/12/Mac workflow小记/","link":"","permalink":"http://yoursite.com/2016/03/12/Mac workflow小记/","excerpt":"在Mac平台下做开发也有一段时间了，虽然说相对于windows平台而言，Mac下的软件资源并不如windows下的那么丰富，但是在适应以及找到合适的软件后，我觉得Mac对我而言更适合做开发。对于开发人员来说，效率至上是毋庸置疑的，因此，拥有一套提升效率的软件和工具对于开发人员来说是至关重要的。这篇博客就记录下我自己开发的workflow，也希望通过这篇博客能与他人分享。 Homebrew Homebrew之于Mac的关系就跟apt之于Linux的关系是一样的，它实际上是Mac下的套件管理器。比如你想安装MySQL、git等等工具软件，都可以使用homebrew来下载和管理。homebrew的安装也非常方便，你可以去到它的官网，根据提示进行安装。安装成功后就使用homebrew的命令去下载和管理你需要的工具软件了。","text":"在Mac平台下做开发也有一段时间了，虽然说相对于windows平台而言，Mac下的软件资源并不如windows下的那么丰富，但是在适应以及找到合适的软件后，我觉得Mac对我而言更适合做开发。对于开发人员来说，效率至上是毋庸置疑的，因此，拥有一套提升效率的软件和工具对于开发人员来说是至关重要的。这篇博客就记录下我自己开发的workflow，也希望通过这篇博客能与他人分享。 Homebrew Homebrew之于Mac的关系就跟apt之于Linux的关系是一样的，它实际上是Mac下的套件管理器。比如你想安装MySQL、git等等工具软件，都可以使用homebrew来下载和管理。homebrew的安装也非常方便，你可以去到它的官网，根据提示进行安装。安装成功后就使用homebrew的命令去下载和管理你需要的工具软件了。注：homebrew的安装程序需要用到Xcode的command line tools。 1234567brew install mysql // 安装MySQLbrew uninstall mysql // 卸载MySQLbrew search mysql // 搜索MySQLbrew upgrade mysql // 更新MySQLbrew list // 显示已经安装的软件列表brew update // 更新homebrewbrew deps mysql // 显示MySQL的包依赖 iTerm2 iTerm2是mac下的替代Terminal的终端工具，可以说iTerm2是Mac下最好的终端工具。它有一些特色功能如下： 标签变色iTerm2 的标签的颜色会变化，以指示该 tab 当前的状态。当该标签有新输出的时候，标签会变成洋红色；新的输出长时间没有查看，标签会变成红色。可在设置中关掉该功能。 智能选中在 iTerm2 中，双击选中，三击选中整行，四击智能选中（智能规则可配置），可以识别网址，引号引起的字符串，邮箱地址等。（很多时候双击的选中就已经很智能了）在 iTerm2 中，选中即复制。即任何选中状态的字符串都被放到了系统剪切板中。 巧用 Command 键按住⌘键:可以拖拽选中的字符串；点击 url：调用默认浏览器访问该网址；点击文件：调用默认程序打开文件；如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行；点击文件夹：在 finder 中打开该文件夹；同时按住option键，可以以矩形选中，类似于vim中的ctrl v操作。 iTerm2的可定制化也是一大特色，详细的定制化步骤可以参见我的另一篇博客。 Alfred3 我对Alfred3的评价是Mac下最逆天的工具。如果你是个键盘党，Alfred绝对可以让你基本摆脱鼠标。丰富的workflow可以让你的操作变得得心应手而且高效。你可以去alfredworkflow上下载安装适合你的workflow。当然，你要是想自己制作workflow也很容易，简单易上手，这也是Alfred workflow资源丰富的原因所在。如果兜里不差钱还是建议去买个终身会员，绝对值得。如果囊中羞涩，这里提供一个破解版本供大家尝鲜。（下载链接） Dash Dash是Mac下的API文档查阅器，其储存了超过150种API离线文档。这可以说是程序员必备利器，不管是从操作体验以及资源的丰富程度都是Mac平台下最好用的。同时，配合Alfred使用，效率会更高。Dash提供免费版也带有付费插件，如果不差钱，支持一下也是无可厚非的。 CheatSheet CheatSheet是一款Mac上非常实用的快捷键快速提醒工具，只需要按住Command键，就会弹出当前应用所有的快捷键列表。所以，即使你记不住一些快捷键也没有关系，有CheatSheet就够了。 Sequel Pro Sequel Pro（原CocoaMySQL）是众多Mac程序员使用的MySQL管理软件，提供了比phpmyadmin更强大的管理能力，帮助用户轻松编辑数据库，表（字段和索引）和列，执行个性化查找以及导出/入数据，快速查询数据。 Sequel Pro它最大的优点是简单、易用。因为这款工具是苹果公司为了吸引Web开发者进入Mac平台而投资的项目。所以它处处体现了苹果公司简洁的设计哲学。说它是全世界最好用的MySQL数据库管理工具是一点也不夸张。 功能特点： 支持多达30种编码方式 快速导出/导入、备份/还原数据库的SQL/CSV文件 最高版本支持MySQL 5.6 内置强大的数据库查询编辑器，有自定义查询中的自动语句高亮功能，可自定义字体，自定义查询占位符. 允许你编辑数据库，表格（字段和索引）和列，执行个性化查找和导入导出数据 自动补全关键词，表名，域名 自动段落化查询命令 IP直连数据库 表触发机制 服务器运行监控Query Favourites for SQL reuse 包括检索功能在内的全表管理设计 快速在Mac上架设本地MySQL数据库 在MAMP/XAMP架构上连接数据库 SSH连接模式 Sublime Text 3 Sublime Text可以说是一款优雅高效地编辑器，越来越受到开发人员的欢迎。这款编辑器区别于其他编辑器的特性主要有以下几点： 随时保留文件的修改 多重选择，同时修改 智能选择 智能感知，一键注释 Goto Anything，智能搜索 自动完成，无处不在 HTML标签输入 标签输入，再简化 简单全面的插件体系 Lantern Lantern是一款免费开源的科学上网的软件，安装和使用极其简单。Lantern让用户能流畅地访问被封锁的互联网站点。Lantern自动检测一个网站是否被封锁。对那些被封锁的网站，Lantern通过自有的服务器或者未封锁地区的用户运行的Lantern来提供访问。如果网站没有被封锁，Lantern选择靠边站。这样浏览器就会直接访问网站，而速度不受影响。 iStat Menus iStat Menus 5 是一款由软件开发商 Bjango 制作的 System Monitor（工具，也是笔者电脑里的必装应用之一，它能让用户最快速、最直观地了解到几乎各硬件所有的运行状态，其中包括：CPU 中央处理器、GPU 图形处理器、Memory 虚拟内存、Network 网络、Battery 电池、Disks 硬盘等。 Cmd Markdown编辑器 Cmd Markdown是一款markdown编辑器，相比于同类markdown编辑器，Cmd Markdown编辑器的优势在于对中文支持比较好，实时的云端文稿，实时同步预览等等。 目前，也就只有这些了，后续如果发现好用的软件会继续更新的。","categories":[{"name":"Mac相关","slug":"Mac相关","permalink":"http://yoursite.com/categories/Mac相关/"}],"tags":[],"keywords":[{"name":"Mac相关","slug":"Mac相关","permalink":"http://yoursite.com/categories/Mac相关/"}]},{"title":"runtime对containsString方法的小改进","slug":"runtime对containsString方法的小改进","date":"2016-02-20T15:23:28.000Z","updated":"2016-09-06T15:23:33.000Z","comments":true,"path":"2016/02/20/runtime对containsString方法的小改进/","link":"","permalink":"http://yoursite.com/2016/02/20/runtime对containsString方法的小改进/","excerpt":"","text":"最近做项目过程中版本适配到iOS 7上出现了一点问题，定位分析了一下发现原来是NSstring的containsString:方法在从中作梗。看了一下文档发现原来containsString:是从iOS 8才加入的，iOS 7 SDK并没有该方法。这个问题解决起来也挺简单的，在iOS 7下可以用如下代码代替containsString:方法： 1BOOL isContained = [aString rangeOfString:bString].location != NSNotFound 不过，我觉得要在每一个需要调用containsString:方法写一遍有点麻烦，把适配的代码抽离出来写入一个方法倒是可以，但我还是觉得有点麻烦，毕竟懒癌患者。于是，我想到了用runtime运行时机制动态添加containsString:方法就可以一劳永逸了。实现的原理也很简单，在iOS 7下判断NSString中是否存在containsString:实例方法，若不存在，则动态添加该方法。这样就不用再需要调用containsString:实例方法去判断了。原理很简单，代码也很简单，还是很符合我这个懒癌患者的口味的嘛。 12345678910111213// NSString+containsStringCategory.h#import &lt;Foundation/Foundation.h&gt;#if __IPHONE_OS_VERSION_MIN_REQUIRED &lt; 80000@interface NSString (containsStringCategory)- (BOOL)containsString:(NSString *)str;@end#endif 1234567891011121314151617181920212223242526272829// NSString+containsStringCategory.m#import &quot;NSString+containsStringCategory.h&quot;#import &lt;objc/runtime.h&gt;#if __IPHONE_OS_VERSION_MIN_REQUIRED &lt; 80000@implementation NSString (containsStringCategory)+ (void)load&#123; @autoreleasepool &#123; [self zs_modernizeSelector:@selector(containsString:) withSelector:@selector(zs_containsString:)]; &#125;&#125;+ (void)zs_modernizeSelector:(SEL)originSelector withSelector:(SEL)newSelector&#123; if (![NSString instancesRespondToSelector:originSelector]) &#123; Method newMethod = class_getInstanceMethod(self, newSelector); class_addMethod(self, originSelector, method_getImplementation(newMethod), method_getTypeEncoding(newMethod)); &#125;&#125;- (BOOL)zs_containsString:(NSString *)str&#123; return [self rangeOfString:str].location != NSNotFound;&#125;@end#endif","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"UIImage加载图片方式的研究","slug":"UIImage加载图片方式的研究","date":"2016-01-20T11:56:39.000Z","updated":"2016-08-30T13:19:34.000Z","comments":true,"path":"2016/01/20/UIImage加载图片方式的研究/","link":"","permalink":"http://yoursite.com/2016/01/20/UIImage加载图片方式的研究/","excerpt":"常用的UIImage加载图片的方式有以下几种： [UIImage imageNamed:name] [UIImage imageWithContentsOfFile:name] [UIImage imageWithData:data] [UIImage imageWithCGImage:imageRef] [UIImage imageWithCIImage:obj] 以上方法中imageNamed:和imageWitData:应用程序会对其自动缓存，不过，它们缓存的实现方式并不相同，后面会有详细说明。除去这两个方法以外剩下的三个方法默认情况下是不会产生缓存的，这三个方法的主要区别在于它们的数据源：imageWithContentsOfFile:从指定文件中创建对象，imageWithCGImage:以CGImageRef来创建对象，imageWithCIImage:以CIImage对象来创建对象。最后两种方法平时用的相对会少一些，简要解释一下CGImage与CIImage的区别：CGImageRef只能代表位图，如果你需要与bitmap数据打交道，无疑CGImage是非常合适的选择。CGImageRef以CG开头就不难想到CGImageRef的相关操作都需要在Core Graphics中进行，比如混合、遮罩等等。CIImage以CI开头，即Core Image，不难理解CIImage是底层的数据对象，它通常包含了与它相关的图像数据，而不是一个图像。默认情况下，CIImage对象是不会被绘图系统渲染的，除非是得到明确的指令。这种机制（“lazy evaluation”）允许核心绘图系统尽可能高效地运行。CIImage通常被运用在GPU优化图像滤镜算法当中。","text":"常用的UIImage加载图片的方式有以下几种： [UIImage imageNamed:name] [UIImage imageWithContentsOfFile:name] [UIImage imageWithData:data] [UIImage imageWithCGImage:imageRef] [UIImage imageWithCIImage:obj] 以上方法中imageNamed:和imageWitData:应用程序会对其自动缓存，不过，它们缓存的实现方式并不相同，后面会有详细说明。除去这两个方法以外剩下的三个方法默认情况下是不会产生缓存的，这三个方法的主要区别在于它们的数据源：imageWithContentsOfFile:从指定文件中创建对象，imageWithCGImage:以CGImageRef来创建对象，imageWithCIImage:以CIImage对象来创建对象。最后两种方法平时用的相对会少一些，简要解释一下CGImage与CIImage的区别：CGImageRef只能代表位图，如果你需要与bitmap数据打交道，无疑CGImage是非常合适的选择。CGImageRef以CG开头就不难想到CGImageRef的相关操作都需要在Core Graphics中进行，比如混合、遮罩等等。CIImage以CI开头，即Core Image，不难理解CIImage是底层的数据对象，它通常包含了与它相关的图像数据，而不是一个图像。默认情况下，CIImage对象是不会被绘图系统渲染的，除非是得到明确的指令。这种机制（“lazy evaluation”）允许核心绘图系统尽可能高效地运行。CIImage通常被运用在GPU优化图像滤镜算法当中。 UIImage缓存原理1.[UIImage imageNamed:name]我通过查看imageNamed方法的调用栈以及查阅苹果相关文档后对UIImage的缓存实现有了清晰的认识。当调用imageNamed方法时，该方法会去内存缓存里去查找与参数一致的image对象并且返回最合适大小的image对象，如果没有找到，该方法则会去本地磁盘中查找然后加载图片并返回image对象，同时将image对象缓存到系统缓存中，以便下次重复使用。更底层一点的解释，当返回image对象时，并未对image的图片数据进行解码。它的解码过程发生在UIImage对象第一次显示到屏幕上的时候，而image对象的缓存也发生在这时候。当解码完成image显示在屏幕上后，应用程序会将image的解码结果保存到缓存中。通常缓存会在收到内存警告时才会被清空。 2.[UIImage imageWithData:data]在查看imageWithData方法的调用栈时发现了有意思的东西。通过二进制数据创建image对象时，实际上在底层调用的是ImageIO/ImageIO.h的CGImageSourceCreateWithData()方法。该方法的第二个参数可以传入key为kCGImageSourceShouldCache的键值对，它的值是CFBooleanRef类型的，默认情况下，在64位机器上它的值为kCFBooleanTrue，而在32位机器上它的值为kCFBooleanFalse。也就是说在64位机器上是会缓存的，而在32位机器上则是不会缓存的。与imageNamed方法类似，图片会在第一次显示到屏幕上时才会进行解码，随后再被缓存到CGImage里面。依据是CGImageSourceCreateWithData()方法第二个参数可以传入key为kCGImageSourceShouldCacheImmediately的键值对，默认情况下它的值是kCFBooleanFalse。 UIImage不缓存 [UIImage imageWithContentsOfFile:name]与前面两个方法略有不同，该方法是同步的（synchronous）。当在主线程（UI）中调用该方法时，会阻塞主线程并从磁盘中加载图片数据，若磁盘数据较大会造成卡顿或者延迟。通常的解决方法是另开一个线程异步完成磁盘加载图片数据的任务，然后在主线程中刷新UI。下面代码给出了一个例子： 123456789dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123; UIImage *image = [UIImage imageWithContentsOfFile:imagePath]; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.button setBackgroundImage:image forState:UIControlStateNormal]; &#125;);&#125;); 当图片显示在屏幕上时，系统并不会对其进行缓存。当图片数据被加载到内存中，它会被标记为可清除（purgeable）。如果数据被清除了且需要再次加载，image对象会再次从指定的文件路径获取数据并加载进内存中。根据它的实现原理，通常该方法的使用场景是图片不需要重复展示，或者图片的数据较大会造成内存警告。当然，这并不是说imageWithContentsOfFile:一定比imageNamed:方法高效，imageWithContentsOfFile:方法的问题在于它会将图片文件全尺寸展示在屏幕上即使是512*512的图片都要占到1M多的内存，加载会影响程序的性能，造成不好的用户体验。针对图片尺寸太大带来的性能问题，比较好的解决方案是用CGImageSource的有关方法，将图片的尺寸缩减到适合的尺寸，减小数据大小。123456789101112131415161718192021#import &lt;ImageIO/ImageIO.h&gt;NSURL *imageFileURL = [NSURL fileURLWithPath:...];CGImageSourceRef imageSource = CGImageSourceCreateWithURL((CFURLRef)imageFileURL, NULL);if (imageSource == NULL) &#123; // Error loading image ... return;&#125;NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithBool:NO], (NSString *)kCGImageSourceShouldCache, nil];CFDictionaryRef imageProperties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, (CFDictionaryRef)options);if (imageProperties) &#123; NSNumber *width = (NSNumber *)CFDictionaryGetValue(imageProperties, kCGImagePropertyPixelWidth); NSNumber *height = (NSNumber *)CFDictionaryGetValue(imageProperties, kCGImagePropertyPixelHeight); NSLog(@&quot;Image dimensions: %@ x %@ px&quot;, width, height); CFRelease(imageProperties);&#125;CFRelease(imageSource);","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]},{"title":"ApplePay线上支付教程","slug":"ApplePay线上支付教程","date":"2016-01-14T12:33:39.000Z","updated":"2016-08-30T13:19:27.000Z","comments":true,"path":"2016/01/14/ApplePay线上支付教程/","link":"","permalink":"http://yoursite.com/2016/01/14/ApplePay线上支付教程/","excerpt":"第一部分 准备阶段1）硬件要求：iPhone6及更新的设备，还有iPad air2和iPad mini3之后的平板，以及apple watch。具体型号（截止2016年2月）：iPhone 6，iPhone 6 Plus，iPhone 6s， iPhone 6s Plus；iPad Air 2，iPad mini 3，iPad mini 4，iPad Pro；还有Apple Watch。 2）系统要求：iPhone或iPad至少要升到iOS 9.2版，手表至少watch OS 2.1。 3）配置支付环境1.进入苹果开发者中心，注册App ID。App ID必须是explicit类型，否则无法使用ApplePay服务。","text":"第一部分 准备阶段1）硬件要求：iPhone6及更新的设备，还有iPad air2和iPad mini3之后的平板，以及apple watch。具体型号（截止2016年2月）：iPhone 6，iPhone 6 Plus，iPhone 6s， iPhone 6s Plus；iPad Air 2，iPad mini 3，iPad mini 4，iPad Pro；还有Apple Watch。 2）系统要求：iPhone或iPad至少要升到iOS 9.2版，手表至少watch OS 2.1。 3）配置支付环境1.进入苹果开发者中心，注册App ID。App ID必须是explicit类型，否则无法使用ApplePay服务。 2.勾选Apple Pay并点击continue，然后点击“submit”提交。 3.在App IDs中找到刚刚注册成功的App ID，点击edit，对Apple Pay进行配置。 4.创建MerchantID。 5.配置Apple Pay服务，勾选Merchant ID。 6.App ID的apple pay选项变成enable表示配置成功。 7.创建Xcode项目，填入刚注册的BundleID。 8.在项目的target-&gt;Capabilities中，打开Apple Pay，并勾选Merchant ID。 第二部分 代码实现项目地址：https://github.com/ZakariyyaSv/ApplePayDemo 一、判断支付环境1.导入Passkit框架，加载view。1#import &lt;PassKit/PassKit.h&gt; 2.判断当前设备是否支持Apple Pay以及wallet中是否有符合所支持网络的银行卡。1234567891011121314151617181920// 1.判断当前设备是否支持ApplePayif ([PKPaymentAuthorizationViewController canMakePayments]) &#123; // 2.判断是否添加了银行卡 if ([PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:@[PKPaymentNetworkChinaUnionPay]]) &#123; // 3.1添加支付按钮，点击跳转去支付 PKPaymentButton *buyBtn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeBuy style:PKPaymentButtonStyleBlack]; [buyBtn addTarget:self action:@selector(buyOnClick) forControlEvents:UIControlEventTouchUpInside]; [self.payView addSubview:buyBtn]; &#125; else &#123; // 3.2添加设置按钮，点击跳转去wallet绑定银行卡 PKPaymentButton *setupBtn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeSetUp style:PKPaymentButtonStyleWhiteOutline]; [setupBtn addTarget:self action:@selector(jumpToWallet) forControlEvents:UIControlEventTouchUpInside]; [self.payView addSubview:setupBtn]; &#125;&#125;else &#123; NSLog(@&quot;The device cannot support ApplePay!&quot;);&#125; 运行效果如下图所示： 3.若wallet中没有绑定所支持网络的银行卡，则点击按钮跳转到wallet中去绑定银行卡。1234- (void)jumpToWallet&#123; PKPassLibrary *walletLibrary = [[PKPassLibrary alloc] init]; [walletLibrary openPaymentSetup];&#125; 4.若该设备支持Apple Pay并且有绑定所支持网络的银行卡则发起支付请求。12345678910111213141516171819202122232425- (void)buyOnClick&#123; NSLog(@&quot;start to pay!&quot;); // 创建支付请求，配置请求信息。 PKPaymentRequest *payRequest = [[PKPaymentRequest alloc] init]; // 国家代码 payRequest.countryCode = @&quot;CN&quot;; // 货币代码 payRequest.currencyCode = @&quot;CNY&quot;; // 商家ID payRequest.merchantIdentifier = @&quot;merchant.com.zakariyya.fabrunMerchant&quot;; // 商家的处理方式 payRequest.merchantCapabilities = PKMerchantCapability3DS; // 商家支持的网络 payRequest.supportedNetworks = @[PKPaymentNetworkChinaUnionPay]; // 配置支付订单的详情 PKPaymentSummaryItem *cameraItem = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;单反相机&quot; amount:[NSDecimalNumber decimalNumberWithString:@&quot;5999.0&quot;] type:PKPaymentSummaryItemTypeFinal]; PKPaymentSummaryItem *totalItem = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;佳能&quot; amount:[NSDecimalNumber decimalNumberWithString:@&quot;5999.0&quot;] type:PKPaymentSummaryItemTypeFinal]; payRequest.paymentSummaryItems = @[cameraItem,totalItem]; // 跳转并验证支付权限 PKPaymentAuthorizationViewController *authViewController = [[PKPaymentAuthorizationViewController alloc] initWithPaymentRequest:payRequest]; authViewController.delegate = self; [self presentViewController:authViewController animated:YES completion:nil];&#125; 支付请求配置包括国家代码、货币代码、商家ID、商家的处理方式、商家支持的网络、订单的详情，这几个要素缺一不可。其中，merchantCapabilities是一个枚举值：123456typedef NS_OPTIONS(NSUInteger, PKMerchantCapability) &#123; PKMerchantCapability3DS = 1UL &lt;&lt; 0, // Merchant supports 3DS PKMerchantCapabilityEMV = 1UL &lt;&lt; 1, // Merchant supports EMV PKMerchantCapabilityCredit NS_ENUM_AVAILABLE_IOS(9_0) = 1UL &lt;&lt; 2, // Merchant supports credit PKMerchantCapabilityDebit NS_ENUM_AVAILABLE_IOS(9_0) = 1UL &lt;&lt; 3 // Merchant supports debit&#125; NS_ENUM_AVAILABLE(NA, 8_0); 这些枚举值当中PKMerchantCapability3DS是必选项，其他的则是可选项。 supportedNetworks是一个包含常量字符串的数组：1234567extern NSString * const PKPaymentNetworkAmex NS_AVAILABLE(NA, 8_0);extern NSString * const PKPaymentNetworkChinaUnionPay NS_AVAILABLE(NA, 9_2);extern NSString * const PKPaymentNetworkDiscover NS_AVAILABLE(NA, 9_0);extern NSString * const PKPaymentNetworkInterac NS_AVAILABLE(NA, 9_2);extern NSString * const PKPaymentNetworkMasterCard NS_AVAILABLE(NA, 8_0);extern NSString * const PKPaymentNetworkPrivateLabel NS_AVAILABLE(NA, 9_0);extern NSString * const PKPaymentNetworkVisa NS_AVAILABLE(NA, 8_0); 国内一般我们用到的会是中国银联，即PKPaymentNetworkChinaUnionPay，注意：iOS 9.2以后才开始支持银联支付。 5.监听用户授权状态1234567891011121314151617181920#pragma mark - PKPaymentAuthorizationViewControllerDelegate// 用户授权成功后调用此方法- (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller didAuthorizePayment:(PKPayment *)payment completion:(void (^)(PKPaymentAuthorizationStatus))completion&#123; // 一般在此处，拿到支付信息，发送给服务端处理，处理完毕后，服务器会返回一个状态来告诉客户端是否支付成功，然后由客户端进行处理。 BOOL isSuccess = YES; if (isSuccess) &#123; completion(PKPaymentAuthorizationStatusSuccess); &#125; else &#123; completion(PKPaymentAuthorizationStatusFailure); &#125;&#125;// 用户授权成功或者用户取消授权操作时调用该方法- (void)paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller&#123; NSLog(@&quot;Authorization did finished!&quot;); [self dismissViewControllerAnimated:YES completion:nil];&#125; 附：","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}]}]}